

add sticker cmd
/*/*

$$$$$$\            $$\                                               
$$  __$$\           $$ |                                              
$$ /  \__|$$\   $$\ $$$$$$$\  $$$$$$$$\  $$$$$$\   $$$$$$\   $$$$$$\  
\$$$$$$\  $$ |  $$ |$$  __$$\ \____$$  |$$  __$$\ $$  __$$\ $$  __$$\ 
 \____$$\ $$ |  $$ |$$ |  $$ |  $$$$ _/ $$$$$$$$ |$$ |  \__|$$ /  $$ |
$$\   $$ |$$ |  $$ |$$ |  $$ | $$  _/   $$   ____|$$ |      $$ |  $$ |
\$$$$$$  |\$$$$$$  |$$$$$$$  |$$$$$$$$\ \$$$$$$$\ $$ |      \$$$$$$  |
 \______/  \______/ \_______/ \________| \_______|\__|       \______/

Project Name : SubZero MD
Creator      : Darrell Mucheri ( Mr Frank OFC )
Repo         : https//github.com/mrfrank-ofc/SUBZERO-MD
Support      : wa.me/18062212660
*/









































































































































































































const { cmd } = require('../command');
const crypto = require('crypto');
const webp = require('node-webpmux');
const axios = require('axios');
const fs = require('fs-extra');
const { exec } = require('child_process');
const { Sticker, createSticker, StickerTypes } = require("wa-sticker-formatter");
const Config = require('../config');

// Take Sticker 

cmd(
    {
        pattern: 'take',
        alias: ['rename', 'stake'],
        desc: 'Create a sticker with a custom pack name.',
        category: 'sticker',
        use: '<reply media or URL>',
        filename: __filename,
    },
    async (conn, mek, m, { quoted, args, q, reply, from }) => {
        if (!mek.quoted) return reply(`*Reply to any sticker.*`);
        if (!q) return reply(`*Please provide a pack name using .take <packname>*`);

        let mime = mek.quoted.mtype;
        let pack = q;

        if (mime === "imageMessage" || mime === "stickerMessage") {
            let media = await mek.quoted.download();
            let sticker = new Sticker(media, {
                pack: pack, 
                type: StickerTypes.FULL,
                categories: ["ü§©", "üéâ"],
                id: "12345",
                quality: 75,
                background: 'transparent',
            });
            const buffer = await sticker.toBuffer();
            return conn.sendMessage(mek.chat, { sticker: buffer }, { quoted: mek });
        } else {
            return reply("*Uhh, Please reply to an image.*");
        }
    }
);

//Sticker create 

cmd(
    {
        pattern: 'sticker',
        react: 'üîÑ',
        alias: ['s', 'stickergif'],
        desc: 'Create a sticker from an image, video, or URL.',
        category: 'sticker',
        use: '<reply media or URL>',
        filename: __filename,
    },
    async (conn, mek, m, { quoted, args, q, reply, from }) => {
        if (!mek.quoted) return reply(`*Reply to any Image or Video, Sir.*`);
        let mime = mek.quoted.mtype;
        let pack = "Created By Yours," || Config.STICKER_NAME ;
        
        if (mime === "imageMessage" || mime === "stickerMessage") {
            let media = await mek.quoted.download();
            let sticker = new Sticker(media, {
                pack: pack, 
                author: 'Mr Frank OFC üéÄ', // Leave blank or customize
                type: StickerTypes.FULL,
                categories: ["ü§©", "üéâ"], 
                id: "12345",
                quality: 75, 
                background: 'transparent',
            });
            const buffer = await sticker.toBuffer();
            return conn.sendMessage(mek.chat, { sticker: buffer }, { quoted: mek });
        } else {
            return reply("*Please reply to an image or use .vsticker if its a video.*");
        }
    }
);


add block and uock

cmd({
    pattern: "block",
    desc: "Block a user.",
    category: "owner",
    react: "üö´",
    filename: __filename,
}, async (conn, mek, m, { isOwner, isGroup, quoted, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    
    let target = "";
    if (isGroup) {
        if (quoted) {
            target = quoted.sender;
        } else if (m.mentionedJid && m.mentionedJid.length > 0) {
            target = m.mentionedJid[0];
        } else {
            return reply("‚ùå In a group, please reply to or mention the user you want to block.");
        }
    } else {
        target = m.chat;
    }
    
    try {
        await conn.updateBlockStatus(target, 'block');
        reply(`üö´ User @${target.split('@')[0]} blocked successfully.`, null, { mentions: [target] });
    } catch (error) {
        console.error("Error blocking user:", error);
        reply(`‚ùå Error blocking user: ${error.message}`);
    }
});
// 5. Unblock User
cmd({
    pattern: "unblock",
    desc: "Unblock a user.",
    category: "owner",
    react: "‚úÖ",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    if (!quoted) return reply("‚ùå Please reply to the user you want to unblock.");
    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'unblock');
        reply(`‚úÖ User ${user} unblocked successfully.`);
    } catch (error) {
        reply(`‚ùå Error unblocking user: ${error.message}`);
    }
});


add sudo cmd to only alkow granted uses to use bot who have been added

const fs = require("fs");
const path = require("path");
const { cmd } = require("../command");

const OWNER_PATH = path.join(__dirname, "../lib/sudo.json");

// Ensure the sudo.json file exists
const ensureOwnerFile = () => {
  if (!fs.existsSync(OWNER_PATH)) {
    fs.writeFileSync(OWNER_PATH, JSON.stringify([]));
  }
};

// Command: Add a temporary owner
cmd({
    pattern: "setsudo",
    alias: ["addsudo", "addowner"],
    desc: "Add a temporary owner",
    category: "owner",
    react: "üòá",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóThis Command Can Only Be Used By My Owner!_");

        // Identify the target user
        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));

        if (owners.includes(target)) {
            return reply("‚ùå This user is already a temporary owner.");
        }

        owners.push(target);
        const uniqueOwners = [...new Set(owners)];
        fs.writeFileSync(OWNER_PATH, JSON.stringify(uniqueOwners, null, 2));

        const successMsg = "‚úÖ Successfully Added User As Temporary Owner";
        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: successMsg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

// Command: Remove a temporary owner
cmd({
    pattern: "delsudo",
    alias: ["delowner", "deletesudo"],
    desc: "Remove a temporary owner",
    category: "owner",
    react: "ü´©",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóThis Command Can Only Be Used By My Owner!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));

        if (!owners.includes(target)) {
            return reply("‚ùå User not found in owner list.");
        }

        const updated = owners.filter(x => x !== target);
        fs.writeFileSync(OWNER_PATH, JSON.stringify(updated, null, 2));

        const successMsg = "‚úÖ Successfully Removed User As Temporary Owner";
        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: successMsg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

// Command: List all temporary owners
cmd({
    pattern: "listsudo",
    alias: ["listowner"],
    desc: "List all temporary owners",
    category: "owner",
    react: "üìã",
    filename: __filename
}, async (conn, mek, m, { from, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóThis Command Can Only Be Used By My Owner!_");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));
        owners = [...new Set(owners)];

        if (owners.length === 0) {
            return reply("‚ùå No temporary owners found.");
        }

        let listMessage = "`ü§¥ List of Sudo Owners:`\n\n";
        owners.forEach((owner, i) => {
            listMessage += `${i + 1}. ${owner.replace("@s.whatsapp.net", "")}\n`;
        });

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: listMessage
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

/*const fs = require("fs");
const path = require("path");
const { cmd } = require("../command");

const OWNER_PATH = path.join(__dirname, "../lib/sudo.json");

// ŸÖÿ∑ŸÖÿ¶ŸÜ ÿ¥Ÿà ŸÅÿß€åŸÑ owner.json Ÿáÿ≥ÿ™
const ensureOwnerFile = () => {
  if (!fs.existsSync(OWNER_PATH)) {
    fs.writeFileSync(OWNER_PATH, JSON.stringify([]));
  }
};

// ÿßŸÅÿ≤ŸàÿØŸÜ ÿ¥ŸÖÿßÿ±Ÿá ÿ®Ÿá owner.json
cmd({
    pattern: "setsudo",
    alias: ["addsudo","addowner"],
    desc: "Add a temporary owner",
    category: "owner",
    react: "üòá",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply, isOwner }) => {
    try {
        if (!isCreator) return reply("_*‚ùóThis Command Can Only Be Used By My Owner !*_");

        // Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ ŸáÿØŸÅ (ÿ¥ŸÖÿßÿ±Ÿá €åÿß ⁄©ÿßÿ±ÿ®ÿ±)
        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        // ÿß⁄Øÿ± Ÿá€å⁄Ü ŸáÿØŸÅ€å Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØŸá ÿ®ŸàÿØÿå Ÿæ€åÿßŸÖ ÿÆÿ∑ÿß ÿ®ÿØŸá
        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let own = JSON.parse(fs.readFileSync("./lib/sudo.json", "utf-8"));

        if (own.includes(target)) {
            return reply("‚ùå This user is already a temporary owner.");
        }

        own.push(target);
        const uniqueOwners = [...new Set(own)];
        fs.writeFileSync("./lib/sudo.json", JSON.stringify(uniqueOwners, null, 2));

        const dec = "‚úÖ Successfully Added User As Temporary Owner";
        await conn.sendMessage(from, {  // ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ await ÿØÿ± ÿß€åŸÜÿ¨ÿß ÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: dec
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

// ÿ≠ÿ∞ŸÅ ÿ¥ŸÖÿßÿ±Ÿá ÿßÿ≤ owner.json
cmd({
    pattern: "delsudo",
    alias: ["delowner","deletesudo"],
    desc: "Remove a temporary owner",
    category: "owner",
    react: "ü´©",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply, isOwner }) => {
    try {
        if (!isCreator) return reply("_*‚ùóThis Command Can Only Be Used By My Owner !*_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        // ÿß⁄Øÿ± Ÿá€å⁄Ü ŸáÿØŸÅ€å Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØŸá ÿ®ŸàÿØÿå Ÿæ€åÿßŸÖ ÿÆÿ∑ÿß ÿ®ÿØŸá
        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let own = JSON.parse(fs.readFileSync("./lib/sudo.json", "utf-8"));

        if (!own.includes(target)) {
            return reply("‚ùå User not found in owner list.");
        }

        const updated = own.filter(x => x !== target);
        fs.writeFileSync("./lib/sudo.json", JSON.stringify(updated, null, 2));

        const dec = "‚úÖ Successfully Removed User As Temporary Owner";
        await conn.sendMessage(from, {  // ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ await ÿØÿ± ÿß€åŸÜÿ¨ÿß ÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: dec
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

cmd({
    pattern: "listsudo",
    alias: ["listowner],
    desc: "List all temporary owners",
    category: "owner",
    react: "üìã",
    filename: __filename
}, async (conn, mek, m, { from, args, isCreator, reply, isOwner }) => {
    try {
    if (!isCreator) return reply("_*‚ùóThis Command Can Only Be Used By My Owner !*_");
        // Check if the user is the owner
        if (!isOwner) {
            return reply("‚ùå You are not the bot owner.");
        }

        // Read the owner list from the file and remove duplicates
        let own = JSON.parse(fs.readFileSync("./lib/sudo.json", "utf-8"));
        own = [...new Set(own)]; // Remove duplicates

        // If no temporary owners exist
        if (own.length === 0) {
            return reply("‚ùå No temporary owners found.");
        }

        // Create the message with owner list
        let listMessage = "\`ü§¥ List of Sudo Owners:\`\n\n";
        own.forEach((owner, index) => {
            listMessage += `${index + 1}. ${owner.replace("@s.whatsapp.net", "")}\n`;
        });

        // Send the message with an image and formatted caption
        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: listMessage
        }, { quoted: mek });
    } catch (err) {
        // Handle errors
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});


*/


add ban

const fs = require("fs");
const path = require("path");
const { cmd } = require("../command");

cmd({
    pattern: "ban",
    alias: ["blockuser", "addban"],
    desc: "Ban a user from using the bot",
    category: "owner",
    react: "‚õî",
    filename: __filename
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóOnly the bot owner can use this command!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));

        if (banned.includes(target)) {
            return reply("‚ùå This user is already banned.");
        }

        banned.push(target);
        fs.writeFileSync("./lib/ban.json", JSON.stringify([...new Set(banned)], null, 2));

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: `‚õî User has been banned from using the bot.`
        }, { quoted: mek });

    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

cmd({
    pattern: "unban",
    alias: ["removeban"],
    desc: "Unban a user",
    category: "owner",
    react: "‚úÖ",
    filename: __filename
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóOnly the bot owner can use this command!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("‚ùå Please provide a number or tag/reply a user.");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));

        if (!banned.includes(target)) {
            return reply("‚ùå This user is not banned.");
        }

        const updated = banned.filter(u => u !== target);
        fs.writeFileSync("./lib/ban.json", JSON.stringify(updated, null, 2));

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: `‚úÖ User has been unbanned.`
        }, { quoted: mek });

    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});

cmd({
    pattern: "listban",
    alias: ["banlist", "bannedusers"],
    desc: "List all banned users",
    category: "owner",
    react: "üìã",
    filename: __filename
}, async (conn, mek, m, { from, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_‚ùóOnly the bot owner can use this command!_");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));
        banned = [...new Set(banned)];

        if (banned.length === 0) return reply("‚úÖ No banned users found.");

        let msg = "`‚õî Banned Users:`\n\n";
        banned.forEach((id, i) => {
            msg += `${i + 1}. ${id.replace("@s.whatsapp.net", "")}\n`;
        });

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/18il7k.jpg" },
            caption: msg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("‚ùå Error: " + err.message);
    }
});



add functions for thes settings to add em or update the ones already present coz they aint working

use betterqsl add it and  uodate the config.js to get value form db that has been set not fixed constant vlaue also create configdb.js


/* Credits Kerm Owner of Kerm MD */

const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions');
const { writeFileSync } = require('fs');
const path = require('path');

let antilinkAction = "off"; // Default state
let warnCount = {}; // Track warnings per user

const os = require('os');
const { exec } = require('child_process');
const axios = require('axios');
const FormData = require('form-data');
const { setConfig, getConfig } = require("../lib/configdb");




// SET BOT IMAGE
cmd({
  pattern: "setbotimage",
  desc: "Set the bot's image URL",
  category: "owner",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
  try {
    if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");

    let imageUrl = args[0];

    // Upload image if replying to one
    if (!imageUrl && m.quoted) {
      const quotedMsg = m.quoted;
      const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
      if (!mimeType.startsWith("image")) return reply("‚ùå Please reply to an image.");

      const mediaBuffer = await quotedMsg.download();
      const extension = mimeType.includes("jpeg") ? ".jpg" : ".png";
      const tempFilePath = path.join(os.tmpdir(), `botimg_${Date.now()}${extension}`);
      fs.writeFileSync(tempFilePath, mediaBuffer);

      const form = new FormData();
      form.append("fileToUpload", fs.createReadStream(tempFilePath), `botimage${extension}`);
      form.append("reqtype", "fileupload");

      const response = await axios.post("https://catbox.moe/user/api.php", form, {
        headers: form.getHeaders()
      });

      fs.unlinkSync(tempFilePath);

      if (typeof response.data !== 'string' || !response.data.startsWith('https://')) {
        throw new Error(`Catbox upload failed: ${response.data}`);
      }

      imageUrl = response.data;
    }

    if (!imageUrl || !imageUrl.startsWith("http")) {
      return reply("‚ùå Provide a valid image URL or reply to an image.");
    }

    await setConfig("BOTIMAGE", imageUrl);

    await reply(`‚úÖ Bot image updated.\n\n*New URL:* ${imageUrl}\n\n‚ôªÔ∏è Restarting...`);
    setTimeout(() => exec("pm2 restart all"), 2000);

  } catch (err) {
    console.error(err);
    reply(`‚ùå Error: ${err.message || err}`);
  }
});

// SET PREFIX
cmd({
  pattern: "setprefix",
  desc: "Set the bot's command prefix",
  category: "owner",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
  if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
  const newPrefix = args[0]?.trim();
  if (!newPrefix || newPrefix.length > 2) return reply("‚ùå Provide a valid prefix (1‚Äì2 characters).");

  await setConfig("PREFIX", newPrefix);

  await reply(`‚úÖ Prefix updated to: *${newPrefix}*\n\n‚ôªÔ∏è Restarting...`);
  setTimeout(() => exec("pm2 restart all"), 2000);
});



// SET BOT NAME
cmd({
  pattern: "setbotname",
  desc: "Set the bot's name",
  category: "owner",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
  if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
  const newName = args.join(" ").trim();
  if (!newName) return reply("‚ùå Provide a bot name.");

  await setConfig("BOTNAME", newName);

  await reply(`‚úÖ Bot name updated to: *${newName}*\n\n‚ôªÔ∏è Restarting...`);
  setTimeout(() => exec("pm2 restart all"), 2000);
});

// SET OWNER NAME
cmd({
  pattern: "setownername",
  desc: "Set the owner's name",
  category: "owner",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
  if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
  const name = args.join(" ").trim();
  if (!name) return reply("‚ùå Provide an owner name.");

  await setConfig("OWNERNAME", name);

  await reply(`‚úÖ Owner name updated to: *${name}*\n\n‚ôªÔ∏è Restarting...`);
  setTimeout(() => exec("pm2 restart all"), 2000);
});

// OLD SETTINGS

/*const { setConfig, getConfig } = require("../lib/configdb");
const { exec } = require("child_process");
const FormData = require('form-data');
const os = require('os');
const axios = require('axios');

cmd({
  pattern: "setbotimage",
  desc: "Set the bot's image URL",
  category: "owner",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
  try {
    if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");

    let imageUrl = args[0];

    // If no URL and replying to an image
    if (!imageUrl && m.quoted) {
      const quotedMsg = m.quoted;
      const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
      if (!mimeType.startsWith("image")) return reply("‚ùå Please reply to an image.");

      const mediaBuffer = await quotedMsg.download();
      const extension = mimeType.includes("jpeg") ? ".jpg" : ".png";
      const tempFilePath = path.join(os.tmpdir(), `botimg_${Date.now()}${extension}`);
      fs.writeFileSync(tempFilePath, mediaBuffer);

      const form = new FormData();
      form.append("fileToUpload", fs.createReadStream(tempFilePath), `botimage${extension}`);
      form.append("reqtype", "fileupload");

      const response = await axios.post("https://catbox.moe/user/api.php", form, {
        headers: form.getHeaders()
      });

      fs.unlinkSync(tempFilePath);

      if (typeof response.data !== 'string' || !response.data.startsWith('https://')) {
        throw `Catbox upload failed: ${response.data}`;
      }

      imageUrl = response.data;
    }

    if (!imageUrl || !imageUrl.startsWith("http")) {
      return reply("‚ùå Provide a valid image URL or reply to an image.");
    }

    setConfig("BOT_IMAGE", imageUrl);

    await reply(`‚úÖ Bot image updated.\n\n*New URL:* ${imageUrl}\n\n‚ôªÔ∏è Restarting...`);
    setTimeout(() => exec("pm2 restart all"), 2000);

  } catch (err) {
    console.error(err);
    reply(`‚ùå Error: ${err.message || err}`);
  }
});




cmd({
    pattern: "setprefix",
    desc: "Set the bot's command prefix",
    category: "owner",
    react: "‚úÖ",
    filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
    if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
    const newPrefix = args[0]?.trim();
    if (!newPrefix || newPrefix.length > 2) return reply("‚ùå Provide a valid prefix (1‚Äì2 characters).");

    setConfig("PREFIX", newPrefix);

    await reply(`‚úÖ Prefix updated to: *${newPrefix}*\n\n‚ôªÔ∏è Restarting...`);
    setTimeout(() => exec("pm2 restart all"), 2000);
});



cmd({
    pattern: "setbotname",
    desc: "Set the bot's name",
    category: "owner",
    react: "‚úÖ",
    filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
    if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
    const newName = args.join(" ").trim();
    if (!newName) return reply("‚ùå Provide a bot name.");

    setConfig("BOT_NAME", newName);

    await reply(`‚úÖ Bot name updated to: *${newName}*\n\n‚ôªÔ∏è Restarting...`);
    setTimeout(() => exec("pm2 restart all"), 2000);
});


cmd({
    pattern: "setownername",
    desc: "Set the owner's name",
    category: "owner",
    react: "‚úÖ",
    filename: __filename
}, async (conn, mek, m, { args, isCreator, reply }) => {
    if (!isCreator) return reply("‚ùó Only the bot owner can use this command.");
    const name = args.join(" ").trim();
    if (!name) return reply("‚ùå Provide an owner name.");

    setConfig("OWNER_NAME", name);

    await reply(`‚úÖ Owner name updated to: *${name}*\n\n‚ôªÔ∏è Restarting...`);
    setTimeout(() => exec("pm2 restart all"), 2000);
});
*/



//SETTINGS MENU

cmd({
    pattern: "setvar",
    alias: ["settings", "cmdlist"],
    react: "‚öôÔ∏è",
    desc: "List all commands and their current status.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { from, isOwner, reply }) => {
    // if (!isOwner) return reply("*üìõ Only the owner can use this command!*");

    const cmdList = `
    ----------------------------------------
    \`\`\`SUBZERO SETTINGS\`\`\`
    -----------------------------------------
    
üîß *1. \`Mode\`*
   - Current Status: ${config.MODE || "public"}
   - Usage: ${config.PREFIX}mode private/public

üéØ *2. \`Auto Typing\`*
   - Current Status: ${config.AUTOTYPING || "off"}
   - Usage: ${config.PREFIX}autotyping on/off

üåê *3. \`Always Online\`*
   - Current Status: ${config.ALWAYSONLINE || "off"}
   - Usage: ${config.PREFIX}alwaysonline on/off

üéôÔ∏è *4. \`Auto Recording\`*
   - Current Status: ${config.AUTORECORDING || "off"}
   - Usage: ${config.PREFIX}autorecording on/off

üìñ *5. \`Auto Read Status\`*
   - Current Status: ${config.AUTOSTATUSREACT || "off"}
   - Usage: ${config.PREFIX}autoreadstatus on/off

üö´ *6. \`Anti Bad Word\`*
   - Current Status: ${config.ANTIBADWORD || "off"}
   - Usage: ${config.PREFIX}antibad on/off

üóëÔ∏è *7. \`Anti Delete\`*
   - Current Status: ${config.ANTIDELETE || "off"}
   - Usage: ${config.PREFIX}antidelete on/off

üñºÔ∏è *8. \`Auto Sticker\`*
   - Current Status: ${config.AUTOSTICKER || "off"}
   - Usage: ${config.PREFIX}autosticker on/off

üí¨ *9. \`Auto Reply\`*
   - Current Status: ${config.AUTOREPLY || "off"}
   - Usage: ${config.PREFIX}autoreply on/off

‚ù§Ô∏è *10. \`Auto React\`*
   - Current Status: ${config.AUTOREACT || "off"}
   - Usage: ${config.PREFIX}autoreact on/off

üì¢ *11. \`Status Reply\`*
   - Current Status: ${config.AUTOSTATUSREPLY || "off"}
   - Usage: ${config.PREFIX}autostatusreply on/off

üîó *12. \`Anti Link\`*
   - Current Status: ${config.ANTILINK || "off"}
   - Usage: ${config.PREFIX}antilink on/off

ü§ñ *13. \`Anti Bot\`*
   - Current Status: ${config.ANTIBOT || "off"}
   - Usage: ${config.PREFIX}antibot off/warn/delete/kick

üíñ *14. \`Heart React\`*
   - Current Status: ${config.HEARTREACT || "off"}
   - Usage: ${config.PREFIX}heartreact on/off

üîß *15. \`Set Prefix\`*
   - Current Prefix: ${config.PREFIX || "."}
   - Usage: ${config.PREFIX}setprefix <new_prefix>

üìå *Note*: Replace \`"on/off"\` with the desired state to enable or disable a feature.
`;

    try {
        // First try to send with image attachment
        await conn.sendMessage(from, {
            image: { url: 'https://files.catbox.moe/18il7k.jpg' },
            caption: cmdList
        }, { quoted: mek });
    } catch (e) {
        console.error('Error sending with image:', e);
        try {
            // Fallback to text only if image fails
            await conn.sendMessage(from, { 
                text: cmdList 
            }, { quoted: mek });
        } catch (error) {
            console.error('Error sending text:', error);
            // Final fallback to simple reply
            await reply(cmdList);
        }
    }
});

// SETTINGS OVER



// WELCOME
cmd({
    pattern: "welcome",
    alias: ["setwelcome"],
    react: "‚úÖ",
    desc: "Enable or disable welcome messages for new members",
    category: "settings",
    filename: __filename
},
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    if (status === "on") {
        config.WELCOME = "true";
        return reply("‚úÖ Welcome messages are now enabled.");
    } else if (status === "off") {
        config.WELCOME = "false";
        return reply("‚ùå Welcome messages are now disabled.");
    } else {
        return reply(`Example: .welcome on`);
    }
});




// ===========
/*
cmd({
    pattern: "mode",
    alias: ["setmode"],
    react: "üîê",
    desc: "Set bot mode to private or public.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ Only the owner can use this command!*");

    // Si aucun argument n'est fourni, afficher le mode actuel et l'usage
    if (!args[0]) {
        return reply(`üìå Current mode: *${config.MODE}*\n\nUsage: .mode private OR .mode public`);
    }

    const modeArg = args[0].toLowerCase();

    if (modeArg === "private") {
        config.MODE = "private";
        return reply("‚úÖ Bot mode is now set to *PRIVATE*.");
    } else if (modeArg === "public") {
        config.MODE = "public";
        return reply("‚úÖ Bot mode is now set to *PUBLIC*.");
    } else {
        return reply("‚ùå Invalid mode. Please use `.mode private` or `.mode public`.");
    }
});
*/


cmd({
    pattern: "mode",
    alias: ["setmode"],
    react: "üîê",
    desc: "Set bot mode to private or public.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { args, isCreator, reply }) => {
    if (!isCreator) return reply("*üìõ Only the owner can use this command!*");

    const currentMode = getConfig("MODE") || "public";

    if (!args[0]) {
        return reply(`üìå Current mode: *${currentMode}*\n\nUsage: .mode private OR .mode public`);
    }

    const modeArg = args[0].toLowerCase();

    if (["private", "public"].includes(modeArg)) {
        setConfig("MODE", modeArg);
        await reply(`‚úÖ Bot mode is now set to *${modeArg.toUpperCase()}*.\n\n‚ôª Restarting bot to apply changes...`);

        exec("pm2 restart all", (error, stdout, stderr) => {
            if (error) {
                console.error("Restart error:", error);
                return;
            }
            console.log("PM2 Restart:", stdout || stderr);
        });
    } else {
        return reply("‚ùå Invalid mode. Please use `.mode private` or `.mode public`.");
    }
});


cmd({
    pattern: "autotyping",
    alias: ["setautotyping"],
    react: "ü´ü",
    description: "Enable or disable auto-typing feature.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    if (!["on", "off"].includes(status)) {
        return reply("*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á:  .·¥Ä·¥ú·¥õ·¥è·¥õ è·¥ò…™…¥…¢ ·¥è…¥*");
    }

    config.AUTOTYPING = status === "on" ? "true" : "false";
    return reply(`Auto typing has been turned ${status}.`);
});
//--------------------------------------------
// ALWAYS_ONLINE COMMANDS
//--------------------------------------------
cmd({
    pattern: "alwaysonline",
    react: "ü´ü",
    alias: ["setalwaysonline"],
    description: "Set bot status to always online or offline.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    if (!["on", "off"].includes(status)) {
        return reply("*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á:  .·¥Ä ü·¥°·¥Ä ès·¥è…¥ ü…™…¥·¥á ·¥è…¥*");
    }

    config.ALWAYSONLINE = status === "on" ? "true" : "false";
    await conn.sendPresenceUpdate(status === "on" ? "available" : "unavailable", from);
    return reply(`Bot is now ${status === "on" ? "online" : "offline"}.`);
});
//--------------------------------------------
//  AUTO_RECORDING COMMANDS
//--------------------------------------------
cmd({
    pattern: "autorecording",
    alias: ["autorecoding","setautorecording"],
    description: "Enable or disable auto-recording feature.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    if (!["on", "off"].includes(status)) {
        return reply("*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á: .·¥Ä·¥ú·¥õ·¥è Ä·¥á·¥Ñ·¥è Ä·¥Ö…™…¥…¢ ·¥è…¥*");
    }

    config.AUTORECORDING = status === "on" ? "true" : "false";
    if (status === "on") {
        await conn.sendPresenceUpdate("recording", from);
        return reply("Auto recording is now enabled. Bot is recording...");
    } else {
        await conn.sendPresenceUpdate("available", from);
        return reply("Auto recording has been disabled.");
    }
});
//--------------------------------------------
// AUTO_VIEW_STATUS COMMANDS
//--------------------------------------------
cmd({
    pattern: "autostatusreact",
    alias: ["setautoreactstatus","autostatusreact"],
    react: "ü´ü",
    desc: "Enable or disable auto-viewing of statuses",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Default value for AUTO_VIEW_STATUS is "false"
    if (args[0] === "on") {
        config.AUTOSTATUSREACT = "true";
        return reply("Autoreact of statuses is now enabled.");
    } else if (args[0] === "off") {
        config.AUTOSTATUSREACT = "false";
        return reply("Autoreact of statuses is now disabled.");
    } else {
        return reply(`*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á:  .autustatusreact on*`);
    }
}); 
//--------------------------------------------
// AUTO_LIKE_STATUS COMMANDS
//--------------------------------------------

cmd({
    pattern: "autostatusview",
    alias: ["setautoviewstatus","autoviewstatus","setautostatusview"],
    desc: "Enable or disable autoview of statuses",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Default value for AUTO_LIKE_STATUS is "false"
    if (args[0] === "on") {
        config.AUTOSTATUSSEEN = "true";
        return reply("Autoview of statuses is now enabled.");
    } else if (args[0] === "off") {
        config.AUTOSTATUSSEEN= "false";
        return reply("Autoview of statuses is now disabled.");
    } else {
        return reply(`Example: .autoviewstatus on`);
    }
});

cmd({
    pattern: "anticall",
    react: "üìû",
    alias: ["statusreaction"],
    desc: "Enable or disable anti-call",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Default value for AUTO_LIKE_STATUS is "false"
    if (args[0] === "on") {
        config.ANTICALL = "true";
        return reply("Anticall  is now enabled.");
    } else if (args[0] === "off") {
        config.ANTICALL = "false";
        return reply("Anticall  is now disabled.");
    } else {
        return reply(`‚≠ï Example: .anticall on/off`);
    }
});
/*
//--------------------------------------------
//  READ-MESSAGE COMMANDS
//--------------------------------------------
cmd({
    pattern: "read-message",
    alias: ["autoread"],
    desc: "enable or disable readmessage.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_STICKER = "true";
        return reply("readmessage feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_STICKER = "false";
        return reply("readmessage feature is now disabled.");
    } else {
        return reply(`_example:  .readmessage on_`);
    }
});
*/
//--------------------------------------------
//  ANI-BAD COMMANDS
//--------------------------------------------
cmd({
    pattern: "antibad",
    alias: ["setantibad"],
    react: "ü´ü",
    alias: ["antibadword"],
    desc: "enable or disable antibad.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.ANTIBADWORD = "true";
        return reply("*anti bad word is now enabled.*");
    } else if (args[0] === "off") {
        config.ANTIBADWORD = "false";
        return reply("*anti bad word feature is now disabled*");
    } else {
        return reply(`_example:  .antibad on_`);
    }
});
//--------------------------------------------
//  AUTO-STICKER COMMANDS
//--------------------------------------------
cmd({
    pattern: "autosticker",
    alias: ["setautosticker"],
    react: "ü´ü",
    alias: ["autosticker"],
    desc: "enable or disable auto-sticker.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTOSTICKER = "true";
        return reply("auto-sticker feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTOSTICKER = "false";
        return reply("auto-sticker feature is now disabled.");
    } else {
        return reply(`_example:  .autosticker on_`);
    }
});
//--------------------------------------------
//  AUTO-REPLY COMMANDS
//--------------------------------------------
cmd({
    pattern: "autoreply",
    alias: ["setautoreply"],
    react: "ü´ü",
    alias: ["autoreply"],
    desc: "enable or disable auto-reply.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTOREPLY = "true";
        return reply("*auto-reply  is now enabled.*");
    } else if (args[0] === "off") {
        config.AUTOREPLY = "false";
        return reply("auto-reply feature is now disabled.");
    } else {
        return reply(`*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á: . ·¥Ä·¥ú·¥õ·¥è Ä·¥á·¥ò ü è ·¥è…¥*`);
    }
});

//--------------------------------------------
//   AUTO-REACT COMMANDS
//--------------------------------------------
cmd({
    pattern: "autoreact",
    alias: ["setautoreact"],
    react: "ü´ü",
    alias: ["autoreact"],
    desc: "Enable or disable the autoreact feature",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTOREACT = "true";
        await reply("autoreact feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTOREACT = "false";
        await reply("autoreact feature is now disabled.");
    } else {
        await reply(`*üî• ·¥áx·¥Ä·¥ç·¥ò ü·¥á: .·¥Ä·¥ú·¥õ·¥è Ä·¥á·¥Ä·¥Ñ·¥õ ·¥è…¥*`);
    }
});
//--------------------------------------------
//  STATUS-REPLY COMMANDS
//--------------------------------------------

cmd({
    pattern: "setautostatusreply",
    react: "ü´ü",
    alias: ["autostatusreply"],
    desc: "enable or disable status-reply.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTOSTATUSREPLY = "true";
        return reply("status-reply feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTOSTATUSREPLY = "false";
        return reply("status-reply feature is now disabled.");
    } else {
        return reply(`*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á:  .s·¥õ·¥Ä·¥õ·¥ús Ä·¥á·¥ò ü è ·¥è…¥*`);
    }
});

//--------------------------------------------
//  ANTILINK1 COMMANDS
//--------------------------------------------
cmd({
    pattern: "antilink1",
    react: "ü´ü",
    desc: "Enable Antilink (warn/delete/kick) or turn off",
    category: "group",
    filename: __filename
}, async (conn, mek, m, { q, reply }) => {
    if (!q) {
        return reply(`*Current Antilink Action:* ${antilinkAction.toUpperCase()}\n\nUse *antilink warn/delete/kick/off* to change it.`);
    }

    const action = q.toLowerCase();
    if (["warn", "delete", "kick", "off"].includes(action)) {
        antilinkAction = action;
        return reply(`*Antilink action set to:* ${action.toUpperCase()}`);
    } else {
        return reply("‚ùå *Invalid option!* Use *antilink warn/delete/kick/off*.");
    }
});
cmd({
    on: "body"
}, async (conn, mek, m, { from, body, isGroup, sender, isBotAdmins, isAdmins, reply }) => {
    if (!isGroup || antilinkAction === "off") return;
    
    if (isUrl(body)) { // Using isUrl to detect links
        if (!isBotAdmins || isAdmins) return;

        return reply(`‚ö†Ô∏è *Warning! Links are not allowed here.*`);
        await conn.sendMessage(from, { delete: mek.key });

        switch (antilinkAction) {
            case "warn":
                warnCount[sender] = (warnCount[sender] || 0) + 1;
                if (warnCount[sender] >= 3) {
                    delete warnCount[sender];
                    await conn.groupParticipantsUpdate(from, [sender], "remove");
                }
                break;

            case "kick":
                await conn.groupParticipantsUpdate(from, [sender], "remove");
                break;
        }
    }
});


let antibotAction = "off"; // Default action is off
let warnings = {}; // Store warning counts per user

cmd({
    pattern: "antibot",
    react: "ü´ü",
    alias: ["antibot"],
    desc: "Enable Antibot and set action (off/warn/delete/kick)",
    category: "group",
    filename: __filename
}, async (conn, mek, m, { q, reply }) => {
    if (!q) {
        return reply(`*Current Antibot Action:* ${antibotAction.toUpperCase()}\n\nUse *antibot off/warn/delete/kick* to change it.`);
    }

    const action = q.toLowerCase();
    if (["off", "warn", "delete", "kick"].includes(action)) {
        antibotAction = action;
        return reply(`*Antibot action set to:* ${action.toUpperCase()}`);
    } else {
        return reply("*ü´ü ·¥áx·¥Ä·¥ç·¥ò ü·¥á: . ·¥Ä…¥·¥õ…™- ô·¥è·¥õ ·¥è“ì“ì/·¥°·¥Ä Ä…¥/·¥Ö·¥á ü·¥á·¥õ·¥á/·¥ã…™·¥Ñ·¥ã*");
    }
});

cmd({
    on: "body"
}, async (conn, mek, m, { from, isGroup, sender, isBotAdmins, isAdmins, reply }) => {
    if (!isGroup || antibotAction === "off") return; // Check if antibot is enabled

    const messageId = mek.key.id;
    if (!messageId || !messageId.startsWith("3EB")) return; // Detect bot-generated messages

    if (!isBotAdmins) return reply("*_I'm not an admin, so I can't take action!_*");
    if (isAdmins) return; // Ignore admins

    await conn.sendMessage(from, { delete: mek.key }); // Delete the detected bot message

    switch (antibotAction) {
        case "kick":
            await conn.groupParticipantsUpdate(from, [sender], "remove");
            break;

        case "warn":
            warnings[sender] = (warnings[sender] || 0) + 1;
            if (warnings[sender] >= 3) {
                delete warnings[sender]; // Reset warning count after kicking
                await conn.groupParticipantsUpdate(from, [sender], "remove");
            } else {
                return reply(`‚ö†Ô∏è @${sender.split("@")[0]}, warning ${warnings[sender]}/3! Bots are not allowed!`, { mentions: [sender] });
            }
            break;
    }
});

//--------------------------------------------
//  ANTILINK COMMANDS
//--------------------------------------------
cmd({
  pattern: "antilink",
  react: "ü´ü",
  alias: ["antilink"],
  desc: "Enable or disable anti-link feature in groups",
  category: "group",
  react: "üö´",
  filename: __filename
}, async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {
    // Check for group, bot admin, and user admin permissions
    if (!isGroup) return reply('This command can only be used in a group.');
    if (!isBotAdmins) return reply('Bot must be an admin to use this command.');
    if (!isAdmins) return reply('You must be an admin to use this command.');

    // Enable or disable anti-link feature
    if (args[0] === "on") {
      config.ANTILINK = "true";
      await reply("Anti-link feature is now enabled in this group.");
    } else if (args[0] === "off") {
      config.ANTILINK = "false";
      await reply("Anti-link feature is now disabled in this group.");
    } else {
      await reply(`*Invalid input! Use either 'on' or 'off'. Example:antilink on*`);
    }
  } catch (error) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${error.message}`);
  }
});
//--------------------------------------------
//   POLL COMMANDS
//--------------------------------------------
cmd({
  pattern: "poll",
  react: "ü´ü",
  category: "group",
  desc: "Create a poll with a question and options in the group.",
  filename: __filename,
}, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, prefix, pushname, reply }) => {
  try {
    let [question, optionsString] = body.split(";");
    
    if (!question || !optionsString) {
      return reply(`Usage: ${prefix}poll question;option1,option2,option3...`);
    }

    let options = [];
    for (let option of optionsString.split(",")) {
      if (option && option.trim() !== "") {
        options.push(option.trim());
      }
    }

    if (options.length < 2) {
      return reply("*Please provide at least two options for the poll.*");
    }

    await conn.sendMessage(from, {
      poll: {
        name: question,
        values: options,
        selectableCount: 1,
        toAnnouncementGroup: true,
      }
    }, { quoted: mek });
  } catch (e) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
  }
});
//--------------------------------------------
// RANDOM SHIP COMMANDS
//--------------------------------------------
cmd({
    pattern: "randomship",
    react: "ü´ü",
    desc: "Randomly ship two members in a group.",
    category: "group",
    react: "üíû",
    filename: __filename
}, async (conn, mek, m, { from, isGroup, participants, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups!");
        
        const members = participants.filter(p => !p.admin); // Exclude admins if needed
        if (members.length < 2) return reply("‚ùå Not enough members to ship!");

        const shuffled = members.sort(() => Math.random() - 0.5);
        const user1 = shuffled[0].id;
        const user2 = shuffled[1].id;

        reply(`üíñ I randomly ship @${user1.split("@")[0]} & @${user2.split("@")[0]}! Cute couple! üíû`, {
            mentions: [user1, user2]
        });

    } catch (e) {
        console.error(e);
        reply("‚ùå Error processing command.");
    }
});
//--------------------------------------------
//  NEW_GC COMMANDS
//--------------------------------------------
cmd({
  pattern: "newgc",
      alias: ["creategc","creategroup"],
  react: "ü´ü",
  category: "group",
  desc: "Create a new group and add participants.",
  filename: __filename,
}, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, reply }) => {
  try {
    if (!body) {
      return reply(`Usage: .newgc group_name;number1,number2,...`);
    }

    const [groupName, numbersString] = body.split(";");
    
    if (!groupName || !numbersString) {
      return reply(`Usage: !newgc group_name;number1,number2,...`);
    }

    const participantNumbers = numbersString.split(",").map(number => `${number.trim()}@s.whatsapp.net`);

    const group = await conn.groupCreate(groupName, participantNumbers);
    console.log('created group with id: ' + group.id); // Use group.id here

    const inviteLink = await conn.groupInviteCode(group.id); // Use group.id to get the invite link

    await conn.sendMessage(group.id, { text: 'ü´ü hello there' });

    reply(`Group created successfully with invite link: https://chat.whatsapp.com/${inviteLink}\nWelcome message sent.`);
  } catch (e) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
  }
});
//--------------------------------------------
//  EXIT COMMANDS
//--------------------------------------------
/*cmd({
  pattern: "exit",
  react: "ü´ü",
  desc: "Leaves the current group",
  category: "group",
}, async (conn, mek, m, { from, reply }) => {
  try {
    // `from` is the group chat ID
    await conn.groupLeave(from);
    reply("Subzero Successfully left the groupüôÇ.");
  } catch (error) {
    console.error(error);
    reply("Failed to leave the group.ü§¶üèΩ‚Äç‚ôÇÔ∏è");
  }
});*/
//--------------------------------------------
//  AUTO_RECORDING COMMANDS
//--------------------------------------------
cmd({
    pattern: "invite2",
    react: "ü´ü",
    alias: ["glink"],
    desc: "Get group invite link.",
    category: "group", // Already group
    filename: __filename,
}, async (conn, mek, m, { from, quoted, body, args, q, isGroup, sender, reply }) => {
    try {
        // Ensure this is being used in a group
        if (!isGroup) return reply("ùêìùê°ùê¢ùê¨ ùêÖùêûùêöùê≠ùêÆùê´ùêû ùêàùê¨ ùêéùêßùê•ùê≤ ùêÖùê®ùê´ ùêÜùê´ùê®ùêÆùê©‚ùó");

        // Get the sender's number
        const senderNumber = sender.split('@')[0];
        const botNumber = conn.user.id.split(':')[0];
        
        // Check if the bot is an admin
        const groupMetadata = isGroup ? await conn.groupMetadata(from) : '';
        const groupAdmins = groupMetadata ? groupMetadata.participants.filter(member => member.admin) : [];
        const isBotAdmins = isGroup ? groupAdmins.some(admin => admin.id === botNumber + '@s.whatsapp.net') : false;
        
        if (!isBotAdmins) return reply("ùêèùê•ùêûùêöùê¨ùêû ùêèùê´ùê®ùêØùê¢ùêùùêû ùêåùêû ùêÄùêùùê¶ùê¢ùêß ùêëùê®ùê•ùêû ‚ùó");

        // Check if the sender is an admin
        const isAdmins = isGroup ? groupAdmins.some(admin => admin.id === sender) : false;
        if (!isAdmins) return reply("ùêèùê•ùêûùêöùê¨ùêû ùêèùê´ùê®ùêØùê¢ùêùùêû ùêåùêû ùêÄùêùùê¶ùê¢ùêß ùêëùê®ùê•ùêû ‚ùó");

        // Get the invite code and generate the link
        const inviteCode = await conn.groupInviteCode(from);
        if (!inviteCode) return reply("Failed to retrieve the invite code.");

        const inviteLink = `https://chat.whatsapp.com/${inviteCode}`;

        // Reply with the invite link
        return reply(`*Here is your group invite link:*\n${inviteLink}`);
        
    } catch (error) {
        console.error("Error in invite command:", error);
        reply(`An error occurred: ${error.message || "Unknown error"}`);
    }
});

//--------------------------------------------
//           BROADCAST COMMANDS
//--------------------------------------------
cmd({
  pattern: "broadcast",
  alias: ["bcall","bc"],
  react: "ü´ü",
  category: "group",
  desc: "Bot makes a broadcast in all groups",
  filename: __filename,
  use: "<text for broadcast.>"
}, async (conn, mek, m, { q, isGroup, isAdmins, reply }) => {
  try {
    if (!isGroup) return reply("‚ùå This command can only be used in groups!");
    if (!isAdmins) return reply("‚ùå You need to be an admin to broadcast in this group!");

    if (!q) return reply("‚ùå Provide text to broadcast in all groups!");

    let allGroups = await conn.groupFetchAllParticipating();
    let groupIds = Object.keys(allGroups); // Extract group IDs

    reply(`üì¢ Sending Broadcast To ${groupIds.length} Groups...\n‚è≥ Estimated Time: ${groupIds.length * 1.5} seconds`);

    for (let groupId of groupIds) {
      try {
        await sleep(1500); // Avoid rate limits
        await conn.sendMessage(groupId, { text: q }); // Sends only the provided text
      } catch (err) {
        console.log(`‚ùå Failed to send broadcast to ${groupId}:`, err);
      }
    }

    return reply(`‚úÖ Successfully sent broadcast to ${groupIds.length} groups!`);
    
  } catch (err) {
    await m.error(`‚ùå Error: ${err}\n\nCommand: broadcast`, err);
  }
});
//--------------------------------------------
//  AUTO_RECORDING COMMANDS
//--------------------------------------------
cmd({
    pattern: "setgrouppp",
    react: "ü´ü",
    desc: "Set full-screen profile picture for groups.",
    category: "group",
    filename: __filename
}, async (conn, mek, m, { quoted, isGroup, isAdmins, isBotAdmins, reply }) => {
    if (!isGroup) return reply("‚ö†Ô∏è This command can only be used in a group.");
    if (!isAdmins) return reply("‚ùå You must be an admin to use this command.");
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to change the group profile picture.");
    if (!quoted || !quoted.image) return reply("‚ö†Ô∏è Reply to an image to set as the group profile picture.");

    try {
        let media = await quoted.download();
        await conn.updateProfilePicture(m.chat, media);
        reply("‚úÖ Group profile picture updated successfully.");
    } catch (e) {
        console.error(e);
        reply(`‚ùå Failed to update group profile picture: ${e.message}`);
    }
});
cmd({
    pattern: "heartreact",
    react: "ü´ü",
    alias: ["heart"],
    desc: "Enable or disable heart react.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { from, args, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ ·¥è…¥ ü è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö!*");

    const option = args[0]?.toLowerCase();
    
    if (option === "on" || option === "true") {
        config.HEARTREACT = "true"; // Set to "true" for enabling
        return reply("‚ù§Ô∏è Heart react is now enabled.");
    } else if (option === "off" || option === "false") {
        config.HEARTREACT = "false"; // Set to "false" for disabling
        return reply("üíî Heart react is now disabled.");
    } else {
        return reply("*üî• Example: .heartreact on* or *[.heartreact off]*");
    }
});


add group menu cmds too 

// ==========================
// Required Modules
// ==========================
const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require('../lib/functions')

// ==========================
// Helper: Custom Message Sender
// ==========================
const sendCustomMessage = async (conn, from, message, mek, m) => {
    await conn.sendMessage(from, {
        image: { url: `https://files.catbox.moe/18il7k.jpg` },
        caption: message,
        contextInfo: {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: '120363304325601080@newsletter',
                newsletterName: '„Äé ùêíùêîùêÅùêôùêÑùêëùêé ùêåùêÉ „Äè',
                serverMessageId: 143
            }
        }
    }, { quoted: mek });
}

//========KICK ALL ============

cmd({
  pattern: "kickall",
  alias: ["removeall", "masskick"],
  desc: "Kick all members from the group (except owner and bot)",
  category: "group",
  react: "‚ùå",
  filename: __filename
}, async (conn, mek, m, {
  from,
  isCreator,
  isBotAdmins,
  isAdmins,
  isGroup,
  reply,
  participants,
  botNumber
}) => {
  try {
    if (!isGroup) return sendCustomMessage(conn, from, "‚ö†Ô∏è This command only works in *groups*.", mek, m);
    if (!isBotAdmins) return sendCustomMessage(conn, from, "‚ùå I must be *admin* to kick members.", mek, m);
    if (!isAdmins && !isCreator) return sendCustomMessage(conn, from, "üîê Only *group admins* or *owner* can use this command.", mek, m);

    const ownerJid = conn.user.id.split(":")[0] + '@s.whatsapp.net';

    // Get all users excluding bot and owner
    let toKick = participants
      .filter(p => p.id !== botNumber && p.id !== ownerJid)
      .map(p => p.id);

    if (toKick.length === 0) {
      return sendCustomMessage(conn, from, "üë• No members to kick (excluding owner & bot).", mek, m);
    }

    for (let user of toKick) {
      await conn.groupParticipantsUpdate(from, [user], "remove");
      await new Promise(resolve => setTimeout(resolve, 1000)); // delay to avoid flood
    }

    await sendCustomMessage(conn, from, `‚úÖ *Kicked ${toKick.length} members from the group.*`, mek, m);

  } catch (err) {
    console.error(err);
    sendCustomMessage(conn, from, "‚ùå Failed to kick all members. Something went wrong.", mek, m);
  }
});



// ==================== KICK COMMAND ====================
cmd({
  pattern: "kick",
  alias: ["k", "remove", "nital"],
  desc: "Remove a user from the group",
  category: "group",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, {
  from,
  isCreator,
  isBotAdmins,
  isAdmins,
  isGroup,
  quoted,
  reply,
  botNumber
}) => {
  try {
    if (!isGroup) return reply("‚ö†Ô∏è This command only works in *groups*.");
    if (!isBotAdmins) return reply("‚ùå I must be *admin* to remove someone.");
    if (!isAdmins && !isCreator) return reply("üîê Only *group admins* or *owner* can use this command.");

    // Consistent user extraction logic
    if (!m.quoted && (!m.mentionedJid || m.mentionedJid.length === 0)) {
      return reply("‚ùì You did not give me a user to remove!");
    }

    let users = m.mentionedJid[0]
      ? m.mentionedJid[0]
      : m.quoted
      ? m.quoted.sender
      : null;

    if (!users) return reply("‚ö†Ô∏è Couldn't determine target user.");

    // Protection checks
    if (users === botNumber) return reply("ü§ñ I can't kick myself!");
    const ownerJid = conn.user.id.split(":")[0] + '@s.whatsapp.net';
    if (users === ownerJid) return reply("üëë That's the owner! I can't remove them.");

    /*await conn.groupParticipantsUpdate(from, [users], "remove");
    reply(`*‚úÖ Successfully removed from group.*`, { mentions: [users] });*/
      await conn.groupParticipantsUpdate(from, [users], "remove");
await sendCustomMessage(conn, from, `*‚úÖ Successfully removed from group.*`, mek, m);


  } catch (err) {
    console.error(err);
    reply("‚ùå Failed to remove user. Something went wrong.");
  }
});

// ==================== PROMOTE COMMAND ====================
cmd({
  pattern: "promote",
  alias: ["p", "giveadmin", "makeadmin"],
  desc: "Promote a user to admin",
  category: "group",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, {
  from,
  isCreator,
  isBotAdmins,
  isAdmins,
  isGroup,
  quoted,
  reply,
  botNumber
}) => {
  try {
    if (!isGroup) return reply("‚ö†Ô∏è This command only works in *groups*.");
    if (!isBotAdmins) return reply("‚ùå I must be *admin* to promote someone.");
    if (!isAdmins && !isCreator) return reply("üîê Only *group admins* or *owner* can use this command.");

    // Consistent user extraction logic
    if (!m.quoted && (!m.mentionedJid || m.mentionedJid.length === 0)) {
      return reply("‚ùì You did not give me a user to promote!");
    }

    let users = m.mentionedJid[0]
      ? m.mentionedJid[0]
      : m.quoted
      ? m.quoted.sender
      : null;

    if (!users) return reply("‚ö†Ô∏è Couldn't determine target user.");

    // Protection checks
    if (users === botNumber) return reply("ü§ñ I can't promote myself!");
    const ownerJid = conn.user.id.split(":")[0] + '@s.whatsapp.net';
    if (users === ownerJid) return reply("üëë Owner is already super admin!");

   /* await conn.groupParticipantsUpdate(from, [users], "promote");
    reply(`*‚úÖ Successfully Promoted to Admin.*`, { mentions: [users] });*/
      await conn.groupParticipantsUpdate(from, [users], "promote");
await sendCustomMessage(conn, from, `*‚úÖ Successfully Promoted to Admin.*`, mek, m);


  } catch (err) {
    console.error(err);
    reply("‚ùå Failed to promote. Something went wrong.");
  }
});

// ==================== DEMOTE COMMAND ====================
cmd({
  pattern: "demote",
  alias: ["d", "dismiss", "removeadmin"],
  desc: "Demote a group admin",
  category: "group",
  react: "‚úÖ",
  filename: __filename
}, async (conn, mek, m, {
  from,
  isCreator,
  isBotAdmins,
  isAdmins,
  isGroup,
  quoted,
  reply,
  botNumber
}) => {
  try {
    if (!isGroup) return reply("‚ö†Ô∏è This command only works in *groups*.");
    if (!isBotAdmins) return reply("‚ùå I must be *admin* to demote someone.");
    if (!isAdmins && !isCreator) return reply("üîê Only *group admins* or *owner* can use this command.");

    // Consistent user extraction logic
    if (!m.quoted && (!m.mentionedJid || m.mentionedJid.length === 0)) {
      return reply("‚ùì You did not give me a user to demote!");
    }

    let users = m.mentionedJid[0]
      ? m.mentionedJid[0]
      : m.quoted
      ? m.quoted.sender
      : null;

    if (!users) return reply("‚ö†Ô∏è Couldn't determine target user.");

    // Protection checks
    if (users === botNumber) return reply("ü§ñ I can't demote myself!");
    const ownerJid = conn.user.id.split(":")[0] + '@s.whatsapp.net';
    if (users === ownerJid) return reply("üëë I can't demote the owner!");

    /*await conn.groupParticipantsUpdate(from, [users], "demote");
    reply(`*‚úÖ Admin Successfully demoted to a normal member.*`, { mentions: [users] });*/
      await conn.groupParticipantsUpdate(from, [users], "demote");
await sendCustomMessage(conn, from, `*‚úÖ Admin Successfully demoted to a normal member.*`, mek, m);


  } catch (err) {
    console.error(err);
    reply("‚ùå Failed to demote. Something went wrong.");
  }
});

// ==========================
// Leave Group Command
// ==========================
cmd({
    pattern: "leave",
    alias: ["left", "leftgc", "leavegc","exit"],
    desc: "Leave the group",
    react: "üëã",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { from, isGroup, senderNumber }) => {
    try {
        if (!isGroup) {
            return await sendCustomMessage(conn, from, "This command can only be used in groups.", mek, m);
        }
        const botOwner = conn.user.id.split(":")[0]; 
        if (senderNumber !== botOwner) {
            return await sendCustomMessage(conn, from, "Only the bot owner can use this command.", mek, m);
        }
        await sendCustomMessage(conn, from, "Leaving group...", mek, m);
        await sleep(1500);
        await conn.groupLeave(from);
        await sendCustomMessage(conn, from, "Goodbye! üëã", mek, m);
    } catch (e) {
        console.error(e);
        await sendCustomMessage(conn, from, `‚ùå Error: ${e}`, mek, m);
    }
});


// ==========================
// Add Member Command
// ==========================
cmd({
    pattern: "add",
    alias: ["a", "invite"],
    desc: "Adds a member to the group",
    category: "admin",
    react: "‚ûï",
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, isBotAdmins, senderNumber }) => {
    if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return await sendCustomMessage(conn, from, "‚ùå Only the bot owner can use this command.", mek, m);
    }
    if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to use this command.", mek, m);
    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, '');
    } else if (q && /^\d+$/.test(q)) {
        number = q;
    } else {
        return await sendCustomMessage(conn, from, "‚ùå Please reply to a message, mention a user, or provide a number to add.", mek, m);
    }
    const jid = number + "@s.whatsapp.net";
    try {
        await conn.groupParticipantsUpdate(from, [jid], "add");
        await sendCustomMessage(conn, from, `‚úÖ Successfully added @${number}`, mek, m);
    } catch (error) {
        console.error("Add command error:", error);
        await sendCustomMessage(conn, from, "‚ùå Failed to add the member.", mek, m);
    }
});


// ==========================
// Remove Member (Kick) Command
// ==========================
cmd({
    pattern: "remove",
    alias: ["kick", "k", "out"],
    desc: "Removes a member from the group",
    category: "admin",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, isBotAdmins, senderNumber }) => {
    if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return await sendCustomMessage(conn, from, "‚ùå Only the bot owner can use this command.", mek, m);
    }
    if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to use this command.", mek, m);
    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, '');
    } else {
        return await sendCustomMessage(conn, from, "‚ùå Please reply to a message or mention a user to remove.", mek, m);
    }
    const jid = number + "@s.whatsapp.net";
    try {
        await conn.groupParticipantsUpdate(from, [jid], "remove");
        await sendCustomMessage(conn, from, `‚úÖ Successfully removed @${number}`, mek, m);
    } catch (error) {
        console.error("Remove command error:", error);
        await sendCustomMessage(conn, from, "‚ùå Failed to remove the member.", mek, m);
    }
});

/*
// ==========================
// Promote Member Command
// ==========================
cmd({
    pattern: "promote",
    alias: ["p", "admin", "makeadmin"],
    desc: "Promotes a member to group admin",
    category: "admin",
    react: "ü§¥",
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, senderNumber, botNumber, isAdmins, isBotAdmins }) => {
    if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
    if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
    if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to use this command.", mek, m);
    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, '');
    } else {
        return await sendCustomMessage(conn, from, "‚ùå Please reply to a message or provide a number to promote.", mek, m);
    }
    if (number === botNumber) return await sendCustomMessage(conn, from, "‚ùå The bot cannot promote itself.", mek, m);
    const jid = number + "@s.whatsapp.net";
    try {
        await conn.groupParticipantsUpdate(from, [jid], "promote");
        await sendCustomMessage(conn, from, `‚úÖ Successfully promoted @${number} to admin.`, mek, m);
    } catch (error) {
        console.error("Promote command error:", error);
        await sendCustomMessage(conn, from, "‚ùå Failed to promote the member.", mek, m);
    }
});


// ==========================
// Demote Admin Command
// ==========================
cmd({
    pattern: "demote",
    alias: ["d", "dismiss", "removeadmin"],
    desc: "Demotes a group admin to a normal member",
    category: "admin",
    react: "üôÖ‚Äç‚ôÇ",
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, senderNumber, botNumber, isAdmins, isBotAdmins }) => {
    if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
    if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
    if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to use this command.", mek, m);
    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, '');
    } else {
        return await sendCustomMessage(conn, from, "‚ùå Please reply to a message or provide a number to demote.", mek, m);
    }
    if (number === botNumber) return await sendCustomMessage(conn, from, "‚ùå The bot cannot demote itself.", mek, m);
    const jid = number + "@s.whatsapp.net";
    try {
        await conn.groupParticipantsUpdate(from, [jid], "demote");
        await sendCustomMessage(conn, from, `‚úÖ Successfully demoted @${number} to a normal member.`, mek, m);
    } catch (error) {
        console.error("Demote command error:", error);
        await sendCustomMessage(conn, from, "‚ùå Failed to demote the member.", mek, m);
    }
});

*/
// ==========================
// Unmute Group Command
// ==========================
cmd({
    pattern: "unmute",
    alias: ["groupunmute","open","unlock"],
    react: "üîä",
    desc: "Unmute the group (Everyone can send messages).",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins }) => {
    try {
        if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to unmute the group.", mek, m);
        await conn.groupSettingUpdate(from, "not_announcement");
        await sendCustomMessage(conn, from, "‚úÖ Group has been unmuted. Everyone can send messages.", mek, m);
    } catch (e) {
        console.error("Error unmuting group:", e);
        await sendCustomMessage(conn, from, "‚ùå Failed to unmute the group. Please try again.", mek, m);
    }
});


// ==========================
// Close Group Immediately Command ("lockgc", "lock", "close")
// ==========================
cmd({
    pattern: "lockgc",
    alias: ["lock", "close", "mute","closegc"],
    react: "üîí",
    desc: "Immediately close the group chat (only admins can send messages).",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins }) => {
    try {
        if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to close the group.", mek, m);
        // Immediately close group chat by updating settings to 'announcement'
        await conn.groupSettingUpdate(from, "announcement");
        await sendCustomMessage(conn, from, "‚úÖ Group chat has been closed. Only admins can send messages.", mek, m);
    } catch (e) {
        console.error("Error closing group:", e);
        await sendCustomMessage(conn, from, "‚ùå Failed to close the group. Please try again.", mek, m);
    }
});

    
// ==========================
// Update Group Description Command
// ==========================
cmd({
    pattern: "updategdesc",
    alias: ["upgdesc", "gdesc"],
    react: "üìú",
    desc: "Change the group description.",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, q }) => {
    try {
        if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to update the group description.", mek, m);
        if (!q) return await sendCustomMessage(conn, from, "‚ùå Please provide a new group description.", mek, m);
        await conn.groupUpdateDescription(from, q);
        await sendCustomMessage(conn, from, "‚úÖ Group description has been updated.", mek, m);
    } catch (e) {
        console.error("Error updating group description:", e);
        await sendCustomMessage(conn, from, "‚ùå Failed to update the group description. Please try again.", mek, m);
    }
});


// ==========================
// Update Group Name Command
// ==========================
cmd({
    pattern: "updategname",
    alias: ["upgname", "gname"],
    react: "üìù",
    desc: "Change the group name.",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, q }) => {
    try {
        if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, "‚ùå Only group admins can use this command.", mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, "‚ùå I need to be an admin to update the group name.", mek, m);
        if (!q) return await sendCustomMessage(conn, from, "‚ùå Please provide a new group name.", mek, m);
        await conn.groupUpdateSubject(from, q);
        await sendCustomMessage(conn, from, `‚úÖ Group name has been updated to: *${q}*`, mek, m);
    } catch (e) {
        console.error("Error updating group name:", e);
        await sendCustomMessage(conn, from, "‚ùå Failed to update the group name. Please try again.", mek, m);
    }
});


// ==========================
// Join Group via Invite Link Command
// ==========================
cmd({
    pattern: "join",
    react: "üì¨",
    alias: ["joinme", "f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, isCreator, isDev, isOwner, isMe, args }) => {
    try {
        const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg;
        if (!isCreator && !isDev && !isOwner && !isMe) return await sendCustomMessage(conn, from, msr.own_cmd, mek, m);
        if (!q) return await sendCustomMessage(conn, from, "*Please write the Group Link*Ô∏è üñáÔ∏è", mek, m);
        let result = args[0].split('https://chat.whatsapp.com/')[1];
        await conn.groupAcceptInvite(result);
        await conn.sendMessage(from, { text: `‚úîÔ∏è *Successfully Joined*` }, { quoted: mek });
    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.error(e);
        await sendCustomMessage(conn, from, `‚ùå *Error Occurred !!*\n\n${e}`, mek, m);
    }
});


// ==========================
// Get Group Invite Link Command
// ==========================
cmd({
    pattern: "invite",
    react: "üñáÔ∏è",
    alias: ["grouplink", "glink"],
    desc: "To Get the Group Invite link",
    category: "group",
    use: '.invite',
    filename: __filename
},
async (conn, mek, m, { from, isGroup, isAdmins, isDev, isBotAdmins }) => {
    try {
        const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg;
        if (!isGroup) return await sendCustomMessage(conn, from, msr.only_gp, mek, m);
        if (!isAdmins && !isDev) return await sendCustomMessage(conn, from, msr.you_adm, mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, msr.give_adm, mek, m);
        const code = await conn.groupInviteCode(from);
        await conn.sendMessage(from, { text: `üñáÔ∏è *Group Link*\n\nhttps://chat.whatsapp.com/${code}` }, { quoted: mek });
    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.error(e);
        await sendCustomMessage(conn, from, `‚ùå *Error Occurred !!*\n\n${e}`, mek, m);
    }
});


// ==========================
// Reset (Revoke) Group Invite Link Command
// ==========================
cmd({
    pattern: "revoke",
    react: "üñáÔ∏è",
    alias: ["revokegrouplink", "resetglink", "revokelink", "f_revoke"],
    desc: "To Reset the group link",
    category: "group",
    use: '.revoke',
    filename: __filename
},
async (conn, mek, m, { from, isGroup, isAdmins, isDev, isBotAdmins }) => {
    try {
        const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg;
        if (!isGroup) return await sendCustomMessage(conn, from, msr.only_gp, mek, m);
        if (!isAdmins && !isDev) return await sendCustomMessage(conn, from, msr.you_adm, mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, msr.give_adm, mek, m);
        await conn.groupRevokeInvite(from);
        await conn.sendMessage(from, { text: `*Group link Reset* ‚õî` }, { quoted: mek });
    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.error(e);
        await sendCustomMessage(conn, from, `‚ùå *Error Occurred !!*\n\n${e}`, mek, m);
    }
});


// ==========================
// Hidetag (Tag All Members with Provided Message) Command
// ==========================
cmd({
    pattern: "hidetag",
    alias: ["htag"],
    react: "üîä",
    desc: "To Tag all Members for Message",
    category: "group",
    use: '.tag <message>',
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, isAdmins, isDev, isBotAdmins, participants }) => {
    try {
        const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg;
        if (!isGroup) return await sendCustomMessage(conn, from, msr.only_gp, mek, m);
        if (!isAdmins && !isDev) return await sendCustomMessage(conn, from, msr.you_adm, mek, m);
        if (!isBotAdmins) return await sendCustomMessage(conn, from, msr.give_adm, mek, m);
        if (!q) return await sendCustomMessage(conn, from, '*Please add a Message* ‚ÑπÔ∏è', mek, m);
        // Send the message with the provided text and mention all members
        await conn.sendMessage(from, { text: q, mentions: participants.map(a => a.id) }, { quoted: mek });
    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.error(e);
        await sendCustomMessage(conn, from, `‚ùå *Error Occurred !!*\n\n${e}`, mek, m);
    }
});


// ==========================
// Tagall Command (Simplified Version)
// ==========================
cmd({
    pattern: "tagall",
    desc: "Tag all members with a heading and message content",
    category: "group",
    use: '.tagall <message>',
    filename: __filename
},
async (conn, mek, m, { from, q, isGroup, participants }) => {
    try {
        if (!isGroup) return await sendCustomMessage(conn, from, "‚ùå This command can only be used in groups.", mek, m);
        if (!q) return await sendCustomMessage(conn, from, "‚ùå Please provide a message to send.", mek, m);
        const header = "üîî `Attention Everyone:`";
        const fullMsg = `${header}\n\n> ${q}\n\n¬© SUBZERO BOT`;
        await conn.sendMessage(from, { text: fullMsg, mentions: participants.map(a => a.id) }, { quoted: mek });
    } catch(e) {
        await sendCustomMessage(conn, from, `‚ùå *Error Occurred!!* \n\n${e}`, mek, m);
    }
});


// ==========================
// Open Group by Time Command
// ==========================
cmd({
    pattern: "opentime",
    react: "üîë",
    desc: "To open group after a set time",
    category: "group",
    use: '.opentime <time> <unit>',
    filename: __filename
},
async (conn, mek, m, { from, prefix, l, args, q, isGroup, isAdmins, participants }) => {
    try {   
        if (!isGroup) return await sendCustomMessage(conn, from, ONLGROUP, mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, ADMIN, mek, m);
        let timer;
        if (args[1] === 'second') {
            timer = args[0] * 1000;
        } else if (args[1] === 'minute') {
            timer = args[0] * 60000;
        } else if (args[1] === 'hour') {
            timer = args[0] * 3600000;
        } else if (args[1] === 'day') {
            timer = args[0] * 86400000;
        } else {
            return await sendCustomMessage(conn, from, '*select:*\nsecond\nminute\nhour\n\n*example*\n10 second', mek, m);
        }
        await sendCustomMessage(conn, from, `_Group will automatically open after ${q}_`, mek, m);
        setTimeout(async () => {
            const openMsg = "```üîìGood News! Group has been opened. Enjoy :)```" +
                            "\n\n> ¬© ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ç Ä “ì Ä·¥Ä…¥·¥ã";
            await conn.groupSettingUpdate(from, 'not_announcement');
            await sendCustomMessage(conn, from, openMsg, mek, m);
        }, timer);
        await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key } });
    } catch (e) {
        await sendCustomMessage(conn, from, '*Error !!*', mek, m);
        l(e);
    }
});


// ==========================
// Close Group by Time Command
// ==========================
cmd({
    pattern: "closetime",
    react: "üîí",
    desc: "To close group after a set time",
    category: "group",
    use: '.closetime <time> <unit>',
    filename: __filename
},
async (conn, mek, m, { from, prefix, l, args, q, isGroup, isAdmins, participants }) => {
    try {   
        if (!isGroup) return await sendCustomMessage(conn, from, ONLGROUP, mek, m);
        if (!isAdmins) return await sendCustomMessage(conn, from, ADMIN, mek, m);
        let timer;
        if (args[1] === 'second') {
            timer = args[0] * 1000;
        } else if (args[1] === 'minute') {
            timer = args[0] * 60000;
        } else if (args[1] === 'hour') {
            timer = args[0] * 3600000;
        } else if (args[1] === 'day') {
            timer = args[0] * 86400000;
        } else {
            return await sendCustomMessage(conn, from, '*select:*\nsecond\nminute\nhour\n\n*Example*\n10 second', mek, m);
        }
        await sendCustomMessage(conn, from, `_Group will be automatically closed after ${q}_`, mek, m);
        setTimeout(async () => {
            const closeMsg = "```üîê Time's Up! Group auto closed.```" +
                             "\n\n> ¬© ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ç Ä “ì Ä·¥Ä…¥·¥ã";
            await conn.groupSettingUpdate(from, 'announcement');
            await sendCustomMessage(conn, from, closeMsg, mek, m);
        }, timer);
        await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key } });
    } catch (e) {
        await sendCustomMessage(conn, from, '*Error !!*', mek, m);
        l(e);
    }
});

// GINFO

cmd({
    pattern: "ginfo",
    react: "üìå",
    alias: ["groupinfo"],
    desc: "Get detailed group information",
    category: "group",
    use: '.ginfo',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/JawadTech3/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(`*üåç This command only works in groups!*\n\n> ¬© G·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö  ô è S·¥ú ô·¥¢·¥á Ä·¥è`)
if (!isAdmins) { if (!isDev) return reply(`*‚ö†Ô∏è You need to be admin to use this!*\n\n> ¬© G·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö  ô è S·¥ú ô·¥¢·¥á Ä·¥è`),{quoted:mek }} 
if (!isBotAdmins) return reply(`*ü§ñ Please make me admin first!*\n\n> ¬© G·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö  ô è S·¥ú ô·¥¢·¥á Ä·¥è`)

const ppUrls = [
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
      ];
let ppUrl = await conn.profilePictureUrl(from, 'image')
if (!ppUrl) { ppUrl = ppUrls[Math.floor(Math.random() * ppUrls.length)];}

const metadata = await conn.groupMetadata(from)
const groupAdmins = participants.filter(p => p.admin);
const listAdmin = groupAdmins.map((v, i) => `‚û§ @${v.id.split('@')[0]}`).join('\n');
const owner = metadata.owner

const gdata = `*„ÄÑ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ GROUP INFO ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„ÄÑ*

üìõ *Name*: ${metadata.subject}
üÜî *JID*: ${metadata.id}
üë• *Members*: ${metadata.size}
üëë *Owner*: @${owner.split('@')[0]}
üìù *Description*: ${metadata.desc?.toString() || 'No description'}

*üëÆ‚Äç‚ôÇÔ∏è Admins List*:
${listAdmin}

*„ÄÑ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„ÄÑ*\n
> ¬© G·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö  ô è S·¥ú ô·¥¢·¥á Ä·¥è`

await conn.sendMessage(from, {
    image: { url: ppUrl },
    caption: gdata,
    mentions: groupAdmins.map(a => a.id)
},{quoted:mek })

} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`*‚ùå Error Occurred!*\n\n${e}\n\n> ¬© G·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö  ô è S·¥ú ô·¥¢·¥á Ä·¥è`)
}
})

this was lib/funcyions.js for abovd
/*‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫
    ‚≠êÔº∞Ôº≤ÔºØÔº™Ôº•Ôº£Ôº¥ ÔºÆÔº°Ôº≠Ôº•:
    Ôº≥ÔºµÔº¢Ôº∫Ôº•Ôº≤ÔºØ Ôº∑Ôº®Ôº°Ôº¥Ôº≥Ôº°Ôº∞Ôº∞ Ôº≠Ôº§ Ôº¢ÔºØÔº¥
    
    ‚≠êÔº§Ôº•Ôº∂Ôº•Ôº¨ÔºØÔº∞Ôº•Ôº≤
     Ôº≠Ôº≤ Ôº¶Ôº≤Ôº°ÔºÆÔº´ 
     
    ‚≠ê Ôº≠Ôºπ Ôº¥Ôº•Ôº°Ôº≠
     Ôº∏Ôº•Ôº≤ÔºØ Ôº£ÔºØÔº§Ôº•Ôº≤Ôº≥
     
    ‚≠ê ÔºØÔºµÔº≤ Ôº∑Ôº•Ôº¢Ôº≥Ôº©Ôº¥Ôº•
     https://github.com/ZwSyntax/SUBZERO-MD

¬© Ôº¥Ôº≤Ôºπ Ôº§Ôº•Ôº£Ôº≤ÔºπÔº∞Ôº¥Ôº©ÔºÆÔºß Ôº©Ôº¶ ÔºπÔºØÔºµ Ôº£Ôº°ÔºÆ‚ö†

‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫‚ï∫*/



const axios = require('axios')

const getBuffer = async(url, options) => {
	try {
		options ? options : {}
		var res = await axios({
			method: 'get',
			url,
			headers: {
				'DNT': 1,
				'Upgrade-Insecure-Request': 1
			},
			...options,
			responseType: 'arraybuffer'
		})
		return res.data
	} catch (e) {
		console.log(e)
	}
}

const getGroupAdmins = (participants) => {
	var admins = []
	for (let i of participants) {
		i.admin !== null  ? admins.push(i.id) : ''
	}
	return admins
}

const getRandom = (ext) => {
	return `${Math.floor(Math.random() * 10000)}${ext}`
}

const h2k = (eco) => {
	var lyrik = ['', 'K', 'M', 'B', 'T', 'P', 'E']
	var ma = Math.log10(Math.abs(eco)) / 3 | 0
	if (ma == 0) return eco
	var ppo = lyrik[ma]
	var scale = Math.pow(10, ma * 3)
	var scaled = eco / scale
	var formatt = scaled.toFixed(1)
	if (/\.0$/.test(formatt))
		formatt = formatt.substr(0, formatt.length - 2)
	return formatt + ppo
}

const isUrl = (url) => {
	return url.match(
		new RegExp(
			/https?:\/\/(www\.)?[-a-zA-Z0-9@:%.+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%+.~#?&/=]*)/,
			'gi'
		)
	)
}

const Json = (string) => {
    return JSON.stringify(string, null, 2)
}

const runtime = (seconds) => {
	seconds = Number(seconds)
	var d = Math.floor(seconds / (3600 * 24))
	var h = Math.floor(seconds % (3600 * 24) / 3600)
	var m = Math.floor(seconds % 3600 / 60)
	var s = Math.floor(seconds % 60)
	var dDisplay = d > 0 ? d + (d == 1 ? ' day, ' : ' days, ') : ''
	var hDisplay = h > 0 ? h + (h == 1 ? ' hour, ' : ' hours, ') : ''
	var mDisplay = m > 0 ? m + (m == 1 ? ' minute, ' : ' minutes, ') : ''
	var sDisplay = s > 0 ? s + (s == 1 ? ' second' : ' seconds') : ''
	return dDisplay + hDisplay + mDisplay + sDisplay;
}

const sleep = async(ms) => {
	return new Promise(resolve => setTimeout(resolve, ms))
}

const fetchJson = async (url, options) => {
    try {
        options ? options : {}
        const res = await axios({
            method: 'GET',
            url: url,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'
            },
            ...options
        })
        return res.data
    } catch (err) {
        return err
    }
}

module.exports = { getBuffer, getGroupA
dmins, getRandom, h2k, isUrl, Json, runtime, sleep , fetchJson}
config.js for above bot

const fs = require('fs');
const path = require('path');
const { getConfig } = require("./lib/configdb");
const settings = require('./settings');

// Load environment variables from config.env if it exists
if (fs.existsSync('config.env')) {
    require('dotenv').config({ path: './config.env' });
}

// Helper function to convert text to boolean
function convertToBool(text, fault = 'true') {
    return text === fault;
}

module.exports = {
    // ===== BOT CORE SETTINGS =====
    CHATBOT: getConfig("CHATBOT") || "on",
    SESSION_ID: settings.SESSION_ID || process.env.SESSION_ID || "",
    PREFIX: getConfig("PREFIX") || settings.PREFIX || ".",
    BOTNAME: process.env.BOTNAME || getConfig("BOTNAME") || "SUBZERO-MD",
    MODE: getConfig("MODE") || process.env.MODE || "public",
    REPO: process.env.REPO || "https://github.com/mrfrankofcc/SUBZERO-MD",
    BAILEYS: process.env.BAILEYS || "@whiskeysockets/baileys",
    TOKEN: process.env.TOKEN || "xJ6QYrPDaRnMG2y5mcvT8tatbsABMg15Gxp1",
    BUTTON: getConfig("BUTTON") || false,

    // ===== OWNER & DEVELOPER INFO =====
    OWNERNUMBER: settings.OWNERNUMBER || process.env.OWNERNUMBER || "263719647303",
    OWNERNAME: process.env.OWNERNAME || getConfig("OWNERNAME") || "Mr Frank",
    DEV: process.env.DEV || "263719647303",
    DEVELOPER_NUMBER: '263719647303@s.whatsapp.net',

    // ===== AUTO-RESPONSE SETTINGS =====
    AUTOREPLY: process.env.AUTOREPLY || "false",
    AUTOSTATUSREPLY: process.env.AUTOSTATUSREPLY || "false",
    AUTOSTATUSMSG: process.env.AUTOSTATUSMSG || "*SUBZERO BOT VIEWED YOUR STATUS ü§ñ*",
    AUTOREADMESSAGE: process.env.AUTOREADMESSAGE || "false",

    // ===== REACTION & STICKER SETTINGS =====
    AUTOREACT: getConfig("AUTOREACT") || process.env.AUTOREACT || "false",
    CUSTOMREACT: process.env.CUSTOMREACT || "false",
    CUSTOMREACTEMOJIS: process.env.CUSTOMREACTEMOJIS || "üíù,üíñ,üíó,‚ù§Ô∏è‚Äçü©π,‚ù§Ô∏è,üß°,üíõ,üíö,üíô,üíú,ü§é,üñ§,ü§ç",
    STICKER_NAME: process.env.STICKERNAME || "SUBZERO-MD",
    AUTOSTICKER: process.env.AUTOSTICKER || "false",
    HEARTREACT: process.env.HEARTREACT || "false",
    OWNERREACT: getConfig("OWNERREACT") || process.env.OWNERREACT || "false",

    // ===== MEDIA & AUTOMATION =====
    AUTOVOICE: process.env.AUTOVOICE || "false",
    AUTORECORDING: getConfig("AUTORECORDING") || process.env.AUTORECORDING || "false",
    AUTOTYPING: getConfig("AUTOTYPING") || process.env.AUTOTYPING || "false",
    BOTIMAGE: getConfig("BOTIMAGE") || "https://mrfrankk-cdn.hf.space/mrfrank/menu.png",

    // ===== SECURITY & ANTI-FEATURES =====
    ANTIDELETE: process.env.ANTIDELETE || "true",
    ANTICALL: getConfig("ANTICALL") || process.env.ANTICALL || "false",
    ANTIBAD: process.env.ANTIBAD || "false",
    ANTILINK: getConfig("ANTILINK") || process.env.ANTILINK || "true",
    ANTIVV: process.env.ANTIVV || "true",
    ANTIBOT: process.env.ANTIBOT || "true",
    DELETELINKS: process.env.DELETELINKS || "false",
    ANTIDELPATH: process.env.ANTIDELPATH || "inbox",
    PMBLOCKER: process.env.PMBLOCKER || "true",

    // ===== BOT BEHAVIOR & APPEARANCE =====
    FOOTER: process.env.FOOTER || "¬© ùòæùôßùôöùôñùô©ùôöùôô ùòΩùôÆ ùôàùôß ùôÅùôßùôñùô£ùô† ùôäùôÅùòæ „ÉÉ",
    ALWAYSONLINE: getConfig("ALWAYSONLINE") || process.env.ALWAYSONLINE || "false",
    AUTOSTATUSREACT: getConfig("AUTOSTATUSREACT") || process.env.AUTOSTATUSREACT || "true",
    AUTOSTATUSSEEN: getConfig("AUTOSTATUSSEEN") || process.env.AUTOSTATUSSEEN || "true",
    AUTOBIO: getConfig("AUTOBIO") || process.env.AUTO_BIO || "false",
    WELCOME_GOODBYE: getConfig("WELCOME_GOODBYE") || process.env.WELCOME_GOODBYE || "false",
    AMDINEVENTS: process.env.ADMINEVENTS || "true"
};