Make it possible to set the swttings on .settings case
 To also set like
.mode private/public
.setprefix !
.setautorecording on/true
And all other sertingsnlike anticall,status view ,statuse reaxt all settings should update immeduately in runtime please then fix change prefix on buttons of serttings thing make it not reply on tits own and say inablid option 


the  update all menus and subemenrus with new thisng like the allmenu

group menu,ownrmne etc like all should have a flaw design
then 

then when bits setting connection msg to it dm 
make it pro like that mesg


then make it send another followed by first one whuch all user settings with their status and guidbon how to change them

 
add this game

const fs = require("fs");
const { cmd } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;

const dbPath = "./lib/ttt-database.json";
const timers = {}; // ÿ™ÿß€åŸÖÿ±Ÿáÿß€å ŸÜŸàÿ®ÿ™

function loadDB() {
  if (!fs.existsSync(dbPath)) return {};
  const data = fs.readFileSync(dbPath, "utf-8");
  return JSON.parse(data || "{}");
}

function saveDB(db) {
  fs.writeFileSync(dbPath, JSON.stringify(db, null, 2));
}

function renderBoard(board) {
  const emojis = [" ", "‚ùå", "‚≠ï"];
  const lines = [];
  for (let i = 0; i < 3; i++) {
    const row = board.slice(i * 3, i * 3 + 3)
      .map((v, idx) => v ? emojis[v] : `${i * 3 + idx + 1}Ô∏è‚É£`).join(" ‚îÉ ");
    lines.push("‚îÉ " + row + " ‚îÉ");
  }
  const sep = "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ";
  return `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n${lines.join("\n" + sep + "\n")}\n‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ`;
}

function checkWin(board, player) {
  const wins = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  return wins.some(line => line.every(i => board[i] === player));
}

function checkDraw(board) {
  return board.every(c => c !== 0);
}

function gameMessage(game, mention1, mention2) {
  return `üéÆ *TIC-TAC-TOE* üéÆ\n\nGame between ${mention1} (‚ùå) and ${mention2} (‚≠ï)\n\n${renderBoard(game.board)}\n\n${game.turn === 1 ? mention1 : mention2}'s turn (${game.turn === 1 ? "‚ùå" : "‚≠ï"})\n\nSend a number (1-9) to make your move.`;
}

// ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å
cmd({
  pattern: "ttt",
  desc: "Start a Tic-Tac-Toe game",
  category: "game",
  filename: __filename
}, async (conn, mek, m, { from, reply, sender, pushname, isGroup, mentionedJid }) => {
  let db = loadDB();

  if (db[from] && !db[from].finished) {
    return reply("‚ö†Ô∏è A game is already running here.");
  }

  if (!isGroup) {
    // ÿØÿ± ⁄Üÿ™ ÿÆÿµŸàÿµ€å: ÿØŸà ÿ®ÿßÿ≤€å⁄©ŸÜ ŸÖÿ¥ÿÆÿµ (ŸÅÿ±ÿ≥ÿ™ŸÜÿØŸá Ÿà ⁄Ø€åÿ±ŸÜÿØŸá)
    const botNumber = conn.user.id.split(":")[0] + "@s.whatsapp.net";
    const opponent = from === sender ? botNumber : from;

    db[from] = {
      players: [sender, opponent],
      waiting: false,
      finished: false,
      board: Array(9).fill(0),
      turn: 1
    };
    saveDB(db);

    const mention1 = `@${sender.split("@")[0]}`;
    const mention2 = `@${opponent.split("@")[0]}`;
    await reply(
      `üéÆ *TIC-TAC-TOE Game Started in Private!*\n\n${gameMessage(db[from], mention1, mention2)}`,
      null,
      { mentions: [sender, opponent] }
    );

    // ÿ™ÿß€åŸÖÿ± ÿ®ÿ±ÿß€å ŸÜŸàÿ®ÿ™
    if (timers[from]) clearTimeout(timers[from]);
    timers[from] = setTimeout(() => {
      let db = loadDB();
      if (db[from] && !db[from].finished) {
        const mention1 = `@${db[from].players[0].split("@")[0]}`;
        const mention2 = `@${db[from].players[1].split("@")[0]}`;
        conn.sendMessage(from, { text: `‚åõÔ∏è *Game timed out!*\nNo move was made within 1 minutes.\nGame between ${mention1} and ${mention2} cancelled.`, mentions: db[from].players });
        delete db[from];
        saveDB(db);
        delete timers[from];
      }
    }, 1 * 60 * 1000);

    return;
  }

  // ÿØÿ± ⁄Øÿ±ŸàŸá: ÿ≠ÿßŸÑÿ™ ÿπÿßÿØ€å ÿ®ÿß ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ®ÿ±ÿß€å join
  db[from] = {
    players: [sender],
    waiting: true,
    finished: false,
    board: Array(9).fill(0),
    turn: 1
  };
  saveDB(db);

  await reply(`üéÆ *Tic-Tac-Toe* game started!\n\nüë§ Player 1: @${sender.split("@")[0]}\n‚è≥ Waiting for player 2 to join...\n\n‚úâÔ∏è Send *join-ttt* to join the game!`, null, { mentions: [sender] });

  if (waitingIntervals[from]) clearInterval(waitingIntervals[from]);
  if (waitingTimeouts[from]) clearTimeout(waitingTimeouts[from]);

  waitingIntervals[from] = setInterval(() => {
    conn.sendMessage(from, { text: "‚è≥ Waiting for player 2 to join... Send 'join-ttt' to join the game." });
  }, 60 * 1000);

  waitingTimeouts[from] = setTimeout(() => {
    let db = loadDB();
    if (db[from] && db[from].waiting) {
      conn.sendMessage(from, { text: "‚åõÔ∏è Game cancelled due to no player 2 joining in 5 minutes." });
      delete db[from];
      saveDB(db);

      clearInterval(waitingIntervals[from]);
      clearTimeout(waitingTimeouts[from]);
      delete waitingIntervals[from];
      delete waitingTimeouts[from];
    }
  }, 5 * 60 * 1000);
});

// ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ®ÿßÿ≤€å
cmd({
  pattern: "leave-ttt",
  desc: "Leave the current Tic-Tac-Toe game",
  category: "game",
  filename: __filename
}, async (conn, mek, m, { from, reply, sender }) => {
  const db = loadDB();

  if (!db[from]) return reply("‚ö†Ô∏è No active game to leave.");

  const game = db[from];

  if (!game.players.includes(sender)) return reply("‚ö†Ô∏è You are not part of the game.");

  const other = game.players.find(p => p !== sender);
  const senderTag = `@${sender.split("@")[0]}`;

  if (timers[from]) {
    clearTimeout(timers[from]);
    delete timers[from];
  }

  delete db[from];
  saveDB(db);

  return reply(`üö™ ${senderTag} left the game. Game cancelled.`, null, { mentions: [sender, other].filter(Boolean) });
});

// ŸÑÿ∫Ÿà ÿ®ÿßÿ≤€å ÿØÿ± ÿ≠ÿßŸÑÿ™ ÿßŸÜÿ™ÿ∏ÿßÿ±
cmd({
  pattern: "cancel-ttt",
  desc: "Cancel an ongoing Tic-Tac-Toe game",
  category: "game",
  filename: __filename
}, async (conn, mek, m, { from, reply, sender }) => {
  const db = loadDB();

  if (!db[from]) {
    return reply("‚ö†Ô∏è No ongoing Tic-Tac-Toe game to cancel.");
  }

  // ŸÅŸÇÿ∑ ÿ≥ÿßÿ≤ŸÜÿØŸá ÿ®ÿßÿ≤€å ŸÖ€å‚Äåÿ™ŸàŸÜŸá ⁄©ŸÜÿ≥ŸÑ ⁄©ŸÜŸá
  if (db[from].players[0] !== sender) {
    return reply("‚ö†Ô∏è Only the game starter can cancel the game.");
  }

  if (timers[from]) {
    clearTimeout(timers[from]);
    delete timers[from];
  }

  delete db[from];
  saveDB(db);

  return reply("‚ùå Game cancelled successfully.");
});


const waitingIntervals = {};
const waitingTimeouts = {};
const invalidTurnWarnings = {};


cmd({
  on: "body"
}, async (conn, mek, m, { from, body, pushname: _0x1279c5, sender, reply }) => {
  const db = loadDB();
  const text = body.trim().toLowerCase();

  // ÿ¨Ÿà€åŸÜ ÿ®Ÿá ÿ®ÿßÿ≤€å
  if (text === "join-ttt") {
    if (!db[from] || !db[from].waiting) {
      return reply("‚ö†Ô∏è No Tic-Tac-Toe game is waiting for players here. Start a game with '.ttt'.");
    }

    if (db[from].players.includes(sender)) {
      return reply("‚ö†Ô∏è You are already in the game.");
    }

    db[from].players.push(sender);
    db[from].waiting = false;
    saveDB(db);

    // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ™ÿß€åŸÖÿ±Ÿáÿß€å waiting ⁄ÜŸàŸÜ ÿ®ÿßÿ≤€å ÿ¥ÿ±Ÿàÿπ ÿ¥ÿØ
    if (waitingIntervals[from]) {
      clearInterval(waitingIntervals[from]);
      delete waitingIntervals[from];
    }
    if (waitingTimeouts[from]) {
      clearTimeout(waitingTimeouts[from]);
      delete waitingTimeouts[from];
    }

    // ÿ™ÿß€åŸÖÿ± ÿ≠ÿ±⁄©ÿ™ ÿ®ÿßÿ≤€å (5 ÿØŸÇ€åŸÇŸá ÿ®ÿ±ÿß€å Ÿáÿ± ÿ≠ÿ±⁄©ÿ™)
    if (timers[from]) clearTimeout(timers[from]);
    timers[from] = setTimeout(() => {
      let db = loadDB();
      if (db[from] && !db[from].finished) {
        const mention1 = `@${db[from].players[0].split("@")[0]}`;
        const mention2 = `@${db[from].players[1].split("@")[0]}`;
        conn.sendMessage(from, { text: `‚åõÔ∏è *Game timed out!*\nNo move was made within 1 minutes.\nGame between ${mention1} and ${mention2} cancelled.`, mentions: db[from].players });
        delete db[from];
        saveDB(db);
        delete timers[from];
      }
    }, 1 * 60 * 1000);

    const player1 = db[from].players[0];
    const player2 = db[from].players[1];

    return reply(`üéÆ Player 2 @${sender.split("@")[0]} joined the game!\n\n${gameMessage(db[from], `@${player1.split("@")[0]}`, `@${player2.split("@")[0]}`)}`, null, { mentions: [player1, player2] });
  }

  // ÿßÿØÿßŸÖŸá ÿ®ÿßÿ≤€å (ÿ≠ÿ±⁄©ÿ™‚ÄåŸáÿß)
  const game = db[from];
  if (!game || game.waiting || game.finished) return;
  if (!game.players.includes(sender)) return;

  if (sender !== game.players[game.turn - 1]) {
    if (!invalidTurnWarnings[from]) invalidTurnWarnings[from] = {};
    if (!invalidTurnWarnings[from][sender]) {
      invalidTurnWarnings[from][sender] = true;
      reply("‚õîÔ∏è It is not your turn.");
    }
    return;
  }

  const move = parseInt(body);
  if (!move || move < 1 || move > 9) return;

  if (game.board[move - 1] !== 0) {
    return reply("‚ö†Ô∏è This cell is already taken. Choose another one.");
  }

  game.board[move - 1] = game.turn;

  if (checkWin(game.board, game.turn)) {
    const winnerMention = `@${game.players[game.turn - 1].split("@")[0]}`;
    await reply(
      `üèÜ *TIC-TAC-TOE RESULT* üèÜ\n\nüéâ Congratulations ${winnerMention}!\nYou won the game playing as ${game.turn === 1 ? "‚ùå" : "‚≠ï"}.\n\n${renderBoard(game.board)}`,
      null,
      { mentions: game.players }
    );
    delete db[from];
    saveDB(db);
    if (timers[from]) {
      clearTimeout(timers[from]);
      delete timers[from];
    }
    return;
  }

  if (checkDraw(game.board)) {
    await reply(`ü§ù The game ended in a draw.\n\n${renderBoard(game.board)}`, null, { mentions: game.players });
    delete db[from];
    saveDB(db);
    if (timers[from]) {
      clearTimeout(timers[from]);
      delete timers[from];
    }
    return;
  }

  // ÿ™ÿ∫€å€åÿ± ŸÜŸàÿ®ÿ™
  game.turn = game.turn === 1 ? 2 : 1;

  // ÿ±€åÿ≥ÿ™ ÿ™ÿß€åŸÖÿ± ÿ≠ÿ±⁄©ÿ™ ÿ®ÿπÿØ€å
  if (timers[from]) clearTimeout(timers[from]);
  timers[from] = setTimeout(() => {
    let db = loadDB();
    if (db[from] && !db[from].finished) {
      const mention1 = `@${db[from].players[0].split("@")[0]}`;
      const mention2 = `@${db[from].players[1].split("@")[0]}`;
      conn.sendMessage(from, { text: `‚åõÔ∏è *Game timed out!*\nNo move was made within 1 minutes.\nGame between ${mention1} and ${mention2} cancelled.`, mentions: db[from].players });
      delete db[from];
      saveDB(db);
      delete timers[from];
    }
  }, 1 * 60 * 1000);

  saveDB(db);

  const mention1 = `@${game.players[0].split("@")[0]}`;
  const mention2 = `@${game.players[1].split("@")[0]}`;
  await reply(gameMessage(game, mention1, mention2), null, { mentions: game.players });
});

this cmd
const { cmd } = require("../command");

cmd({
  pattern: "cid",
  alias: ["newsletter", "channelid"],
  react: "‚è≥",
  desc: "Get WhatsApp Channel info from link",
  category: "whatsapp",
  filename: __filename
}, async (conn, mek, m, {
  from,
  args,
  q,
  reply
}) => {
  try {
    if (!q) return reply("‚ùé Please provide a WhatsApp Channel link.\n\n*Example:* .cinfo https://whatsapp.com/channel/123456789");

    const match = q.match(/whatsapp\.com\/channel\/([\w-]+)/);
    if (!match) return reply("‚ö†Ô∏è *Invalid channel link format.*\n\nMake sure it looks like:\nhttps://whatsapp.com/channel/xxxxxxxxx");

    const inviteId = match[1];

    let metadata;
    try {
      metadata = await conn.newsletterMetadata("invite", inviteId);
    } catch (e) {
      return reply("‚ùå Failed to fetch channel metadata. Make sure the link is correct.");
    }

    if (!metadata || !metadata.id) return reply("‚ùå Channel not found or inaccessible.");

    const infoText = `\`üì° Channel Info\`\n\n` +
      `üõ†Ô∏è *ID:* ${metadata.id}\n` +
      `üìå *Name:* ${metadata.name}\n` +
      `üë• *Followers:* ${metadata.subscribers?.toLocaleString() || "N/A"}\n` +
      `üìÖ *Created on:* ${metadata.creation_time ? new Date(metadata.creation_time * 1000).toLocaleString("id-ID") : "Unknown"}`;

    if (metadata.preview) {
      await conn.sendMessage(from, {
        image: { url: `https://pps.whatsapp.net${metadata.preview}` },
        caption: infoText
      }, { quoted: m });
    } else {
      await reply(infoText);
    }

  } catch (error) {
    console.error("‚ùå Error in .cinfo plugin:", error);
    reply("‚ö†Ô∏è An unexpected error occurred.");
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

cmd({
  pattern: "remini",
  alias: ["enhance", "hq", "qualityup"],
  react: '‚ú®',
  desc: "Enhance photo quality using Remini AI",
  category: "utility",
  use: ".remini [reply to image]",
  filename: __filename
}, async (client, message, { reply, quoted }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = quoted || message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    // Create temp file
    const tempFilePath = path.join(os.tmpdir(), `remini_input_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Enhance image using Remini API
    const apiUrl = `https://apis.davidcyriltech.my.id/remini?url=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { 
      responseType: 'arraybuffer',
      timeout: 60000 // 1 minute timeout
    });

    // Check if response is valid image
    if (!response.data || response.data.length < 100) {
      throw "API returned invalid image data";
    }

    // Save enhanced image
    const outputPath = path.join(os.tmpdir(), `remini_output_${Date.now()}.jpg`);
    fs.writeFileSync(outputPath, response.data);

    // Send the enhanced image with loading message
    await reply("üîÑ Enhancing image quality...");
    await client.sendMessage(message.chat, {
      image: fs.readFileSync(outputPath),
      caption: "‚úÖ Image enhanced successfully!",
    }, { quoted: message });

    // Clean up
    fs.unlinkSync(outputPath);

  } catch (error) {
    console.error('Remini Error:', error);
    await reply(`‚ùå Error: ${error.message || "Failed to enhance image. The image might be too large or the API is unavailable."}`);
  }
});


yts 
make sure u handle pakcage.json
/*

$$$$$$\            $$\                                               
$$  __$$\           $$ |                                              
$$ /  \__|$$\   $$\ $$$$$$$\  $$$$$$$$\  $$$$$$\   $$$$$$\   $$$$$$\  
\$$$$$$\  $$ |  $$ |$$  __$$\ \____$$  |$$  __$$\ $$  __$$\ $$  __$$\ 
 \____$$\ $$ |  $$ |$$ |  $$ |  $$$$ _/ $$$$$$$$ |$$ |  \__|$$ /  $$ |
$$\   $$ |$$ |  $$ |$$ |  $$ | $$  _/   $$   ____|$$ |      $$ |  $$ |
\$$$$$$  |\$$$$$$  |$$$$$$$  |$$$$$$$$\ \$$$$$$$\ $$ |      \$$$$$$  |
 \______/  \______/ \_______/ \________| \_______|\__|       \______/

Project Name : SubZero MD
Creator      : Darrell Mucheri ( Mr Frank OFC )
Repo         : https//github.com/mrfrank-ofc/SUBZERO-MD
Support      : wa.me/18062212660
*/









































































































































































































const config = require('../config')
const l = console.log
const { cmd, commands } = require('../command')
const dl = require('@bochilteam/scraper')  
const ytdl = require('yt-search');
const fs = require('fs-extra')
var videotime = 60000 // 1000 min
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
cmd({
    pattern: "yts",
    alias: ["ytsearch"],
    use: '.yts sameer kutti',
    react: "üîé",
    desc: "Search and get details from youtube.",
    category: "search",
    filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, umarmd, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return reply('*Please give me words to search *E.g* .yts SUBZERO-MD*')
try {
let yts = require("yt-search")
var arama = await yts(q);
} catch(e) {
    l(e)
return await conn.sendMessage(from , { text: '*Error !!*' }, { quoted: mek } )
}
var mesaj = '';
arama.all.map((video) => {
mesaj += ' *üñ≤Ô∏è' + video.title + '*\nüîó ' + video.url + '\n\n'
});
await conn.sendMessage(from , { text:  mesaj }, { quoted: mek } )
} catch (e) {
    l(e)
  reply('*Error !!*')
}
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

cmd({
  pattern: "removebg",
  alias: ["rmbg", "nobg", "transparentbg"],
  react: 'üñºÔ∏è',
  desc: "Remove background from an image",
  category: "utility",
  use: ".removebg [reply to image]",
  filename: __filename
}, async (client, message, { reply, quoted }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = quoted || message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    // Create temp file
    const tempFilePath = path.join(os.tmpdir(), `removebg_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Remove background using API
    const apiUrl = `https://apis.davidcyriltech.my.id/removebg?url=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

    // Check if response is valid image
    if (!response.data || response.data.length < 100) { // Minimum size check
      throw "API returned invalid image data";
    }

    // Save processed image
    const outputPath = path.join(os.tmpdir(), `removebg_output_${Date.now()}.png`);
    fs.writeFileSync(outputPath, response.data);

    // Send the processed image
    await client.sendMessage(message.chat, {
      image: fs.readFileSync(outputPath),
      caption: "Background removed successfully!",
    }, { quoted: message });

    // Clean up
    fs.unlinkSync(outputPath);

  } catch (error) {
    console.error('RemoveBG Error:', error);
    await reply(`‚ùå Error: ${error.message || error}`);
  }
});


then create me an antilink cmd which either kicks,deletes links or warn and elete

const { cmd } = require('../command');
const config = require("../config");

// Anti-Link System
const linkPatterns = [
  /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,
  /^https?:\/\/(www\.)?whatsapp\.com\/channel\/([a-zA-Z0-9_-]+)$/,
  /wa\.me\/\S+/gi,
  /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,
  /https?:\/\/(?:www\.)?youtube\.com\/\S+/gi,
  /https?:\/\/youtu\.be\/\S+/gi,
  /https?:\/\/(?:www\.)?facebook\.com\/\S+/gi,
  /https?:\/\/fb\.me\/\S+/gi,
  /https?:\/\/(?:www\.)?instagram\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?tiktok\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,
  /https?:\/\/ngl\/\S+/gi,
  /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,
  /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?medium\.com\/\S+/gi
];

cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply
}) => {
  try {
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    if (containsLink && config.ANTI_LINK === 'true') {
      await conn.sendMessage(from, { 'delete': m.key }, { 'quoted': m });
      await conn.sendMessage(from, {
        'text': `‚ö†Ô∏è Links are not allowed in this group.\n@${sender.split('@')[0]}. Bastard Eliminated. üö´`,
        'mentions': [sender]
      }, { 'quoted': m });

      await conn.groupParticipantsUpdate(from, [sender], "remove");
    }
  } catch (error) {
    console.error(error);
    reply("An error occurred while processing the message.");
  }
});

